<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring 文件上传]]></title>
    <url>%2F2017%2F12%2F27%2Ffileupload%2F</url>
    <content type="text"><![CDATA[Spring 文件上传 文件上传工具类 FileUploadUtil 1234567891011121314151617181920212223242526272829303132333435363738/** * 上传文件的公共方法 * @param uploadDir 上传文件目录 * @param file 上传对象 * @return 文件上传后的结果 * key = successFlag (boolean)表示文件是否上传成功 * key = fileName (String)表示文件的文件名 */public static Map&lt;String,Object&gt; executeUpload(String uploadDir, MultipartFile file)&#123; Map&lt;String,Object&gt; resultMap = new HashMap&lt;&gt;(); try &#123; //文件后缀名 String suffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(".")); //上传文件名 String filename = UUID.randomUUID() + suffix; //如果目录不存在，自动创建文件夹 File dir = new File(uploadDir); if(!dir.exists()) &#123; dir.mkdir(); &#125; //服务器端保存的文件对象 File serverFile = new File(uploadDir + filename); //将上传的文件写入到服务器端文件内 file.transferTo(serverFile); //打印文件存储信息 logger.info("文件上传成功，存储位置：&#123;&#125;&#123;&#125;",uploadDir,filename); //封装返回信息（是否成功标志、随机生成的文件名） resultMap.put("successFlag",true); resultMap.put("fileName",filename); &#125; catch (IOException e) &#123; e.printStackTrace(); logger.error("文件上传失败！"); resultMap.put("successFlag",false); &#125; return resultMap;&#125; 单文件上传方法1234567891011121314151617181920212223242526272829/** * 上传文件方法 * @param file 前台上传的文件对象 * @return */@RequestMapping(value = "/upload",method = RequestMethod.POST)@ResponseBodypublic Object upload(HttpServletRequest request, MultipartFile file)&#123; Map&lt;String,Object&gt; resultMap = new HashMap&lt;&gt;(); try &#123; //上传目录地址 String uploadDir = request.getSession().getServletContext().getRealPath("/") +"upload/"; //调用上传方法 Map&lt;String,Object&gt; ans = FileUploadUtil.executeUpload(uploadDir,file); if (ans.get("successFlag").equals(true))&#123; resultMap.put("name",ans.get("fileName")); &#125; else &#123; resultMap.put("msg","false"); &#125; &#125;catch (Exception e) &#123; //打印错误堆栈信息 e.printStackTrace(); resultMap.put("msg","false"); &#125; return resultMap;&#125; 多文件上传方法1234567891011121314151617181920212223242526272829303132333435363738/** * 上传多个文件 * @param request 请求对象 * @param file 上传文件集合 * @return */@RequestMapping(value = "/uploads",method = RequestMethod.POST)@ResponseBodypublic Object uploads(HttpServletRequest request,MultipartFile[] file)&#123; Map&lt;String,Object&gt; resultMap = new HashMap&lt;&gt;(); StringBuffer fileName = new StringBuffer(); try &#123; //上传目录地址 String uploadDir = request.getSession().getServletContext().getRealPath("/") +"upload/"; //遍历文件数组执行上传 for (int i =0;i&lt;file.length;i++) &#123; if(file[i] != null) &#123; //调用上传方法 Map&lt;String,Object&gt; ans = FileUploadUtil.executeUpload(uploadDir, file[i]); if (ans.get("successFlag").equals(true))&#123; if (i == file.length - 1) &#123; fileName.append(ans.get("fileName")); &#125; else &#123; fileName.append(ans.get("fileName") + ","); &#125; &#125; &#125; &#125; resultMap.put("name",fileName); &#125;catch (Exception e) &#123; //打印错误堆栈信息 e.printStackTrace(); resultMap.put("msg","false"); &#125; return resultMap;&#125; 文件下载 一般情况下，只需要将文件路径返回给前端，通过点击文件路径，就能实现文件下载。 12345678910111213141516171819202122232425262728293031323334353637383940414243@RequestMapping(value = "/download")@ResponseBodypublic void download(HttpServletRequest request, HttpServletResponse response)&#123; //System.out.println(name); String name = "16cd89a7-1160-4ec4-8ef5-4ad6f2e96002.doc"; try&#123; String uploadDir = request.getSession().getServletContext().getRealPath("/") +"upload/"; File file = new File(uploadDir + name); //判断文件是否存在 if(!file.exists()) &#123; return; &#125; //判断文件类型 String mimeType = URLConnection.guessContentTypeFromName(file.getName()); if(mimeType == null) &#123; mimeType = "application/octet-stream"; &#125; response.setContentType(mimeType); //设置文件响应大小 response.setContentLengthLong(file.length()); //文件名编码，解决乱码问题 String fileName = file.getName(); String encodedFileName = null; String userAgentString = request.getHeader("User-Agent"); String browser = UserAgent.parseUserAgentString(userAgentString).getBrowser().getGroup().getName(); if(browser.equals("Chrome") || browser.equals("Internet Exploer") || browser.equals("Safari")) &#123; encodedFileName = URLEncoder.encode(fileName,"utf-8").replaceAll("\\+", "%20"); &#125; else &#123; encodedFileName = MimeUtility.encodeWord(fileName); &#125; //设置Content-Disposition响应头，一方面可以指定下载的文件名，另一方面可以引导浏览器弹出文件下载窗口 response.setHeader("Content-Disposition", "attachment;fileName=\"" + encodedFileName + "\""); //文件下载 InputStream in = new BufferedInputStream(new FileInputStream(file)); FileCopyUtils.copy(in, response.getOutputStream()); &#125;catch (IOException e)&#123; &#125;&#125; 文件拷贝上的性能差异分析及参考文章 通过零拷贝实现有效数据传输 Java IO和Java NIO在文件拷贝上的性能差异分析 Java 复制大文件方式（nio2 FileChannel 拷贝文件能力测试） SpringMVC上传文件的三种方式 Spring MVC中优雅地进行文件下载以及下载文件名乱码的一些探讨 Springboot文件下载]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring 邮件服务]]></title>
    <url>%2F2017%2F12%2F27%2Fjavamail%2F</url>
    <content type="text"><![CDATA[对JavaMailSender用法做个简单的小结在Spring Boot的工程中的pom.xml中引入spring-boot-starter-mail依赖：12345&lt;!-- 邮件依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 12345&lt;!-- 模板引擎 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 在配置文件中添加相应的属性 在application.properties中 123456spring.mail.host=smtp.qq.comspring.mail.username=邮箱账号spring.mail.password=授权码（不是邮箱密码）spring.mail.properties.mail.smtp.auth=truespring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=true 在application.yml中 1234567891011121314mail: host: smtp.qq.com（QQ邮箱为例） username: 邮箱账号 password: 授权码（不是邮箱密码） default-encoding: UTF-8 fromMail: addr: 发送方邮箱 properties: mail: smtp: auth: true starttls: enable: true required: true 简单使用 由于Spring Boot的starter模块提供了自动化配置，所以在引入了spring-boot-starter-mail依赖之后，会根据配置文件中的内容去创建JavaMailSender实例，因此我们可以直接在需要使用的地方直接@Autowired来引入邮件发送对象。我们通过使用SimpleMailMessage实现了简单的邮件发送，也可以使用MimeMessage来设置复杂一些的邮件内容。 编写MailService和MailServiceImpl 编写MailService接口 123456789public interface MailService &#123; public void sendSimpleMail(String to, String subject, String content); public void sendHtmlMail(String to, String subject, String content); public void sendAttachmentsMail(String to, String subject, String content, String filePath); public void sendInlineResourceMail(String to, String subject, String content, String rscPath, String rscId);&#125; 编写MailServiceImpl实现类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118@Servicepublic class MailServiceImpl implements MailService&#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private JavaMailSender mailSender;// @Value("$&#123;mail.fromMail.addr&#125;")// private String from; private String from = "1006936991@qq.com"; /** * 发送文本邮件 * @param to 目标邮箱 * @param subject 邮件主题 * @param content 邮件内容 */ @Override public void sendSimpleMail(String to, String subject, String content) &#123; SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(from); message.setTo(to); message.setSubject(subject); message.setText(content); try &#123; mailSender.send(message); logger.info("简单邮件已经发送。"); &#125; catch (Exception e) &#123; logger.error("发送简单邮件时发生异常！", e); &#125; &#125; /** * 发送html邮件 * @param to * @param subject * @param content */ @Override public void sendHtmlMail(String to, String subject, String content) &#123; MimeMessage message = mailSender.createMimeMessage(); try &#123; //true表示需要创建一个multipart message MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); mailSender.send(message); logger.info("html邮件发送成功"); &#125; catch (MessagingException e) &#123; logger.error("发送html邮件时发生异常！", e); &#125; &#125; /** * 发送带附件的邮件 * @param to * @param subject * @param content * @param filePath */ public void sendAttachmentsMail(String to, String subject, String content, String filePath)&#123; MimeMessage message = mailSender.createMimeMessage(); try &#123; MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); FileSystemResource file = new FileSystemResource(new File(filePath)); String fileName = filePath.substring(filePath.lastIndexOf(File.separator)); helper.addAttachment(fileName, file); //helper.addAttachment("test"+fileName, file); mailSender.send(message); logger.info("带附件的邮件已经发送。"); &#125; catch (MessagingException e) &#123; logger.error("发送带附件的邮件时发生异常！", e); &#125; &#125; /** * 发送正文中有静态资源（图片）的邮件 * @param to * @param subject * @param content * @param rscPath * @param rscId */ public void sendInlineResourceMail(String to, String subject, String content, String rscPath, String rscId) &#123; MimeMessage message = mailSender.createMimeMessage(); try &#123; MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); FileSystemResource res = new FileSystemResource(new File(rscPath)); helper.addInline(rscId, res); mailSender.send(message); logger.info("嵌入静态资源的邮件已经发送。"); &#125; catch (MessagingException e) &#123; logger.error("发送嵌入静态资源的邮件时发生异常！", e); &#125; &#125;&#125; 测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.smile.service;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import org.thymeleaf.TemplateEngine;import org.thymeleaf.context.Context;/** * Created by pyt on 2017/12/26/0026. */@RunWith(SpringRunner.class)@SpringBootTestpublic class MailServiceTest &#123; @Autowired private MailService mailService; @Autowired private TemplateEngine templateEngine; @Test public void testSimpleMail() throws Exception &#123; mailService.sendSimpleMail("307080368@qq.com","test simple mail"," pyt,this is simple mail"); &#125; @Test public void testHtmlMail() throws Exception &#123; String content="&lt;html&gt;\n" + "&lt;body&gt;\n" + " &lt;h3&gt;hello world ! 这是一封html邮件!&lt;/h3&gt;\n" + "&lt;/body&gt;\n" + "&lt;/html&gt;"; mailService.sendHtmlMail("307080368@qq.com","test simple mail",content); &#125; @Test public void sendAttachmentsMail() &#123; String filePath="F:\\javaPhotoTest\\LearnDo\\1513167730446da70.doc"; mailService.sendAttachmentsMail("307080368@qq.com", "主题：带附件的邮件", "涛哥有附件，请查收！", filePath); &#125; @Test public void sendInlineResourceMail() &#123; String rscId = "myImg"; String content="&lt;html&gt;&lt;body&gt;这是有图片的邮件：&lt;img src=\'cid:" + rscId + "\' &gt;&lt;/body&gt;&lt;/html&gt;"; String imgPath = "F:\\javaPhotoTest\\InnerParty\\1513761305358f62a.jpg"; mailService.sendInlineResourceMail("307080368@qq.com", "主题：这是有图片的邮件", content, imgPath, rscId); &#125; @Test public void sendTemplateMail() &#123; //创建邮件正文 Context context = new Context(); context.setVariable("id", "1"); String emailContent = templateEngine.process("emailTemplate", context); mailService.sendHtmlMail("307080368@qq.com","主题：这是模板邮件",emailContent); &#125;&#125; 备注: 12345html语言可以带上图片链接&lt;img src=&quot;c:/test.jpg&quot;&gt; &lt;/img&gt;那么我们在发送邮件的时候就需要对这些链接的图片做特殊处理,否则在对方接收到邮件的时候会看不到图片。我们特殊处理的方法就是把它们当成附件发送，但不显示在附件里。要做到这些就首先需要对输入的content进行解析，找到所带图片的路径。然后把content中&lt;img src=&quot;c:/test.jpg&quot;&gt; &lt;/img&gt; 这段代码变成&lt;img src=&quot;cid:IMG&quot;&gt; &lt;/img&gt; Spring Boot中开发Web应用时，模板默认位于resources/templates/目录下，可以添加邮件模板 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="zh" xmlns:th="http://www.thymeleaf.org"&gt; &lt;head&gt; &lt;meta charset="UTF-8"/&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 您好,这是验证邮件,请点击下面的链接完成验证,&lt;br/&gt; &lt;!--&lt;a href="#" th:href="@&#123; http://www.panyutao.top/&#123;id&#125;(id=$&#123;id&#125;) &#125;"&gt;查看博客&lt;/a&gt;--&gt; &lt;a href="#" th:href="@&#123; http://www.panyutao.top &#125;"&gt;查看博客&lt;/a&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot日志管理]]></title>
    <url>%2F2017%2F12%2F25%2Flogback%2F</url>
    <content type="text"><![CDATA[简单学习 SLF4J+LogbackSLF4J简介 slf4j的全称是Simple Loging Facade For Java，即它仅仅是一个为Java程序提供日志输出的统一接口，并不是一个具体的日志实现方案，就比如JDBC一样，只是一种规则而已。所以单独的slf4j是不能工作的，必须搭配其他具体的日志实现方案。slf4j只是一种接口，它本身并不关心你底层使用的是什么日志实现方案，所以它支持各种日志实现方案。简单的说，只要我们在类库中使用slf4j打日志，那么底层使用什么日志实现方案是使用者决定的，怎么决定？依靠配置文件和jar库。 SLF4J优势使用SLF4J的而不是直接使用 Log4j, commons logging, logback 或者 java.util.logging 1.在你的开源或内部类库中使用SLF4J会使得它独立于任何一个特定的日志实现，这意味着不需要管理多个日志配置或者多个日志类库，你的客户端会很感激这点。2.SLF4J提供了基于占位符的日志方法，这通过去除检查isDebugEnabled(), isInfoEnabled()等等，提高了代码可读性。3.通过使用SLF4J的日志方法，你可以延迟构建日志信息（Srting）的开销，直到你真正需要，这对于内存和CPU都是高效的。4.作为附注，更少的暂时的字符串意味着垃圾回收器（Garbage Collector）需要做更好的工作，这意味着你的应用程序有为更好的吞吐量和性能。 SLF4J+Logback配置pom.xml 配置123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; 新建 logback.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒当scan为true时，此属性生效。默认的时间间隔为1分钟。debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。--&gt;&lt;configuration scan="false" scanPeriod="60 seconds" debug="false"&gt; &lt;!-- 定义日志的根目录 --&gt; &lt;property name="LOG_HOME" value="F:\\javaPhotoTest\\log" /&gt; &lt;!-- 定义日志文件名称 --&gt; &lt;property name="appName" value="pan"&gt;&lt;/property&gt; &lt;!-- ch.qos.logback.core.ConsoleAppender 表示控制台输出 --&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 日志输出格式：%d表示日期时间，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息，%n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt; &lt;appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 指定日志文件的名称 --&gt; &lt;file&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;.log&lt;/file&gt; &lt;!-- 当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名 TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 滚动时产生的文件的存放位置及文件名称 %d&#123;yyyy-MM-dd&#125;：按天进行日志滚动 %i：当文件大小超过maxFileSize时，按照i进行文件滚动 --&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log&lt;/fileNamePattern&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每天滚动， 且maxHistory是365，则只保存最近365天的文件，删除之前的旧文件。注意，删除旧文件是， 那些为了归档而创建的目录也会被删除。 --&gt; &lt;MaxHistory&gt;365&lt;/MaxHistory&gt; &lt;!-- 当日志文件超过maxFileSize指定的大小是，根据上面提到的%i进行日志文件滚动 注意此处配置SizeBasedTriggeringPolicy是无法实现按文件大小进行滚动的，必须配置timeBasedFileNamingAndTriggeringPolicy --&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;!-- 日志输出格式：%d表示日期时间，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息，%n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [ %thread ] - [ %-5level ] [ %logger&#123;50&#125; : %line ] - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- logger主要用于存放日志对象，也可以定义日志类型、级别 name：表示匹配的logger类型前缀，也就是包的前半部分 level：要记录的日志级别，包括 TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR additivity：作用在于children-logger是否使用 rootLogger配置的appender进行输出，false：表示只用当前logger的appender-ref，true：表示当前logger的appender-ref和rootLogger的appender-ref都有效 --&gt; &lt;!-- hibernate logger --&gt; &lt;!--&lt;logger name="org.hibernate" level="error" /&gt;--&gt; &lt;!-- Spring framework logger --&gt; &lt;logger name="org.springframework" level="error" additivity="false"&gt;&lt;/logger&gt; &lt;logger name="com.smile.dao" level="trace"&gt; &lt;appender-ref ref="file" /&gt; &lt;/logger&gt; &lt;!-- root与logger是父子关系，没有特别定义则默认为root，任何一个类只会和一个logger对应， 要么是定义的logger，要么是root，判断的关键在于找到这个logger，然后判断这个logger的appender和level。 --&gt; &lt;root level="info"&gt; &lt;appender-ref ref="console" /&gt; &lt;appender-ref ref="file" /&gt; &lt;/root&gt;&lt;/configuration&gt; 备注关于&lt;Encoding&gt;UTF-8&lt;/Encoding&gt; 1.设置Encoding。在appender中增加一行UTF-8，但是在启动中报错，说是不能识别Encoding元素。有人说Encoding在0.9.22以后版本中已经不能用了。2.设置charset, 在encoder 中增加一行 UTF-8，重新启动系统，日志中中文显示正常了。 附加Why do we declare Loggers static final?为什么要将日志记录定义为static以及final？ private - so that no other class can hijack your logger static - so there is only one logger instance per class, also avoiding attempts to serialize loggers final - no need to change the logger over the lifetime of the class]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 拦截器]]></title>
    <url>%2F2017%2F12%2F25%2Finterceptor%2F</url>
    <content type="text"><![CDATA[概述 Web开发中，我们除了使用 Filter 来过滤web请求外，还可以使用Spring提供的HandlerInterceptor（拦截器）。HandlerInterceptor 的功能跟过滤器类似，但是提供更精细的的控制能力：在request被响应之前、request被响应之后、视图渲染之前以及request全部结束之后。我们不能通过拦截器修改request内容，但是可以通过抛出异常（或者返回false）来暂停request的执行。 实现自定义拦截器三步走： 1.创建我们自己的拦截器类并实现 HandlerInterceptor 接口。 2.创建一个Java类继承WebMvcConfigurerAdapter，并重写 addInterceptors 方法。 3.实例化我们自定义的拦截器，然后将对像手动添加到拦截器链中（在addInterceptors方法中添加）。 样例登录状态拦截器12345678910111213141516171819202122232425262728293031323334public class SessionInterceptor implements HandlerInterceptor&#123; //在请求处理之前进行调用（Controller方法调用之前） @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object o) throws Exception &#123; System.out.println(request.getRequestURI()); //登录不做拦截 if(request.getRequestURI().equals("/user/login") || request.getRequestURI().equals("/user/login_view")) &#123; return true; &#125; //验证session是否存在 Object obj = request.getSession().getAttribute("_session_user"); if(obj == null) &#123; response.sendRedirect("/user/login_view"); return false; &#125; return true; &#125; //请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后） @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; &#125; //在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行（主要是用于进行资源清理工作） @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; &#125;&#125; 12345678@Configurationpublic class MyInterceptorConfig extends WebMvcConfigurerAdapter&#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new SessionInterceptor()).addPathPatterns("/**"); &#125;&#125; 处理时间拦截器123456789101112131415161718192021222324public class ChanelInterceptor implements HandlerInterceptor &#123; private static Logger logger = LoggerFactory.getLogger(ChanelInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object o) throws Exception &#123; logger.info("============================拦截器启动=============================="); request.setAttribute("starttime",System.currentTimeMillis()); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object o, ModelAndView modelAndView) throws Exception &#123; logger.info("===========================执行处理完毕============================="); long starttime = (long) request.getAttribute("starttime"); request.removeAttribute("starttime"); long endtime = System.currentTimeMillis(); logger.info("============请求地址："+request.getRequestURI()+"：处理时间：&#123;&#125;",(endtime-starttime)+"ms"); &#125; @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; logger.info("============================拦截器关闭=============================="); &#125;&#125; 1234567@Configurationpublic class MyInterceptorConfig extends WebMvcConfigurerAdapter&#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new ChanelInterceptor()).addPathPatterns("/**"); &#125;&#125;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis-generator]]></title>
    <url>%2F2017%2F12%2F25%2Fmappergenerator%2F</url>
    <content type="text"><![CDATA[Intellij IDEA 使用MyBatis-generator 自动生成MyBatis代码 步骤1在maven项目的pom.xml 添加mybatis-generator-maven-plugin 插件，如图： 123456789&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt;&lt;/plugin&gt; 步骤2 在maven项目下的src/main/resources 目录下建立名为 generatorConfig.xml的配置文件，作为mybatis-generator-maven-plugin 插件的执行目标 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- 数据库驱动包位置 --&gt; &lt;classPathEntry location="D:\mysql-5.7.19-winx64\mysql-connector-java-5.1.35.jar" /&gt; &lt;context id="MysqlTables" targetRuntime="MyBatis3"&gt; &lt;!--是否去除自动生成的注释 是：true 否：false--&gt; &lt;commentGenerator&gt; &lt;property name="suppressAllComments" value="true" /&gt; &lt;/commentGenerator&gt; &lt;!-- 数据库驱动类、链接URL、用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://120.79.6.242:3306/mytest?characterEncoding=utf8" userId="root" password="Swust306"&gt; &lt;!--&lt;jdbcConnection driverClass="oracle.jdbc.driver.OracleDriver" connectionURL="jdbc:oracle:thin:@localhost:1521:orcl" userId="msa" password="msa"&gt;--&gt; &lt;/jdbcConnection&gt; &lt;!--非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成模型的包名和位置 --&gt; &lt;javaModelGenerator targetPackage="com.smile.domain" targetProject="src\main\java"&gt; &lt;!--是否让schema作为包的后缀--&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;!--从数据库返回的值被清理前后的空格--&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成的映射文件包名和位置 --&gt; &lt;sqlMapGenerator targetPackage="com.smile.dao" targetProject="src\main\java"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.smile.dao" targetProject="src\main\java"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成那些表(更改tableName和domainObjectName就可以) --&gt; &lt;table schema="" tableName="article_info" domainObjectName="ArticleInfo"/&gt; &lt;!--&lt;table tableName="user_info" domainObjectName="UserInfo" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false" /&gt;--&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 步骤3 在Intellij IDEA添加一个“Run运行”选项，使用maven运行mybatis-generator-maven-plugin插件，如图：]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JXL操作Excel模板]]></title>
    <url>%2F2017%2F12%2F24%2Fjxl20171223%2F</url>
    <content type="text"><![CDATA[JXL操作Excel简单总结一下使用JXL来对Excel模板进行添加数据 最近遇到个需要，要对表头较为复杂的Excel进行数据的填充，考虑到表头的复杂性，没有选择一步步去合并单元格等操作来生成表头，故采用直接复制模板，然后对相应单元格进行操作，以此文章贴出代码来对其进行简单总结。 基础参考12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import com.excel.jxl.model.User;import jxl.Workbook;import jxl.read.biff.BiffException;import jxl.write.Boolean;import jxl.write.*;import jxl.write.Number;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.math.BigDecimal;import java.text.SimpleDateFormat;import java.util.Date;/** * Created by pyt on 2017/12/24/0022. */public class JxlReadExport &#123; private static final int MAX_ROWS = 100; public static void main(String[] args) throws IOException, BiffException &#123; // 表格要导出的目录 String outPath = "C:\\Users\\susq\\Desktop\\sheet.xls"; FileOutputStream is = new FileOutputStream(outPath); // 模板文件路径 String templePath = "C:\\Users\\susq\\Desktop\\模板.xls"; // 读取模板文件 Workbook wb = Workbook.getWorkbook(new File(templePath)); // 根据模板文件创建可写的文件，注意这里是createWorkbook(),创建而不是获取 WritableWorkbook wwb = Workbook.createWorkbook(is, wb); // 注意这里是getSheet(), 通过索引，获取模板文件中的sheet页第一页 WritableSheet sheet = wwb.getSheet(0); for(int i=1; i&lt;=MAX_ROWS; i++) &#123; // 从第二行开始插入，第一行表头 User user = new User((long) i, "张三", "14", true, new Date(), new BigDecimal("111112345.6789")); // 第一个参数指定单元格的列数、第二个参数指定单元格的行数，第三个指定写的字符串内容 // 填充数字， import jxl.write.Number; Number label1 = new Number(0, i, user.getId()); // 填充文本 Label label2 = new Label(1, i, user.getName()); Label label3 = new Label(2, i, user.getAge()); // 填充布尔值， import jxl.write.Boolean; Boolean label4 = new Boolean(3, i, user.getSex()); // 填充日期 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); String date = sdf.format(user.getCreateTime()); Label label5 = new Label(4, i, date); // 填充格式化的数字, 保留6位小数，不足六位的时候有几位保留几位。非小数部分用千位符隔开 jxl.write.NumberFormat nf = new jxl.write.NumberFormat("###,###,###.######"); jxl.write.WritableCellFormat wcf = new jxl.write.WritableCellFormat(nf); jxl.write.Number label6 = new jxl.write.Number(5, i, user.getSalary().doubleValue(), wcf); try &#123; sheet.addCell(label1); sheet.addCell(label2); sheet.addCell(label3); sheet.addCell(label4); sheet.addCell(label5); sheet.addCell(label6); &#125; catch (WriteException e) &#123; e.printStackTrace(); &#125; &#125; try &#123; wwb.write(); wwb.close(); is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (WriteException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 根据模板，生成对应的Excel，并填充数据(文本)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import jxl.CellView;import jxl.Workbook;import jxl.WorkbookSettings;import jxl.format.ScriptStyle;import jxl.format.UnderlineStyle;import jxl.read.biff.BiffException;import jxl.write.Boolean;import jxl.write.*;import jxl.write.Number;import jxl.write.biff.RowsExceededException;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.math.BigDecimal;import java.text.SimpleDateFormat;import java.util.Date;public class Test &#123; private static final int MAX_ROWS = 7; public static void main(String[] args) throws IOException, BiffException &#123; // TODO Auto-generated method stub // 表格要导出的目录 String outPath = "C:\\Users\\swust306xu\\Desktop\\sheet.xls"; FileOutputStream is = new FileOutputStream(outPath); // 模板文件路径 String templePath = "C:\\Users\\swust306xu\\Desktop\\业务发展指标.xls"; // 读取模板文件 Workbook wb = Workbook.getWorkbook(new File(templePath)); WorkbookSettings wbSettings = new WorkbookSettings (); wbSettings.setWriteAccess(null); // 根据模板文件创建可写的文件，注意这里是createWorkbook(),创建而不是获取 WritableWorkbook wwb = Workbook.createWorkbook(is, wb , wbSettings); // 注意这里是getSheet(), 通过索引，获取模板文件中的sheet页第一页 WritableSheet sheet = wwb.getSheet(0); WritableFont titleWf = new WritableFont(WritableFont.createFont("宋体"),// 字体 12,//WritableFont.DEFAULT_POINT_SIZE, // 字号 WritableFont.NO_BOLD, // 粗体 false, // 斜体 UnderlineStyle.NO_UNDERLINE, // 下划线 Colour.BLACK, // 字体颜色 ScriptStyle.NORMAL_SCRIPT); WritableCellFormat cFormat = new WritableCellFormat(titleWf); try &#123; cFormat.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,jxl.format.Colour.BLACK); &#125; catch (WriteException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; CellView cellView = new CellView(); cellView.setAutosize(true); //设置自动大小 Label lab = null; for(int i=5; i&lt;=MAX_ROWS; i++) &#123; // 从第二行开始插入，第一行表头 for(int j=0;j&lt;22;j++) &#123; sheet.setColumnView(i, cellView);//根据内容自动设置列宽 lab = new Label(j,i,"测试方法",cFormat); //Label(col,row,str); try &#123; sheet.addCell(lab); &#125; catch (RowsExceededException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (WriteException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; try &#123; wwb.write(); wwb.close(); is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (WriteException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>jxl</category>
      </categories>
      <tags>
        <tag>jxl</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令]]></title>
    <url>%2F2017%2F12%2F11%2Fhexocommon%2F</url>
    <content type="text"><![CDATA[Hexo命令总结常用命令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 复合命令12hexo deploy -g #生成加部署hexo server -g #生成加预览 命令简写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 部署步骤每次部署都可以按照下面的步骤，或者用上面的复合命令123hexo cleanhexo generatehexo deploy 本地测试12hexo g #生成hexo s #启动本地服务，进行文章预览调试 浏览器输入 http://localhost:4000 ，查看搭建效果。此后的每次变更_config.yml 文件或者新建文件都可以先用此命令调试，尤其是当你想调试新添加的主题时。可以用一条简化的命令 1hexo s -g 文章头部格式12345678---title: hexocommondate: 2017-12-11 21:23:17tags: - hexocategories: - hexo--- 基本配置参考文章：http://www.shenzekun.cn/hexo的next主题个性化配置教程.html]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post和Get的区别]]></title>
    <url>%2F2017%2F12%2F11%2Fpostget%2F</url>
    <content type="text"><![CDATA[什么是 HTTP？ 超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。 HTTP 的工作方式是客户机与服务器之间的请求-应答协议。 web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。 举例：客户端（浏览器）向服务器提交HTTP请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。GET请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：/test/demo_form.asp?name1=value1&amp;name2=value2 GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 POST 请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的： POST /test/demo_form.asp HTTP/1.1 Host: w3schools.com name1=value1&amp;name2=value2 POST 请求不会被缓存 POST 请求不会保留在浏览器历史记录中 POST 不能被收藏为书签 GET POST 请求对数据长度没有要求 … GET POST 后退按钮/刷新 可收藏为书签 不可收藏为书签 书签 能被缓存 不能缓存 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中 参数不会保存在浏览器历史中 对数据长度的限制 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 无限制。 对数据类型的限制 只允许 ASCII 字符。 没有限制。也允许二进制数据。 安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是URL的一部分。在发送密码或其他敏感信息时绝不要使用 GET POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 可见性 数据在 URL 中对所有人都是可见的。 数据不会显示在 URL 中。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>post</tag>
        <tag>get</tag>
      </tags>
  </entry>
</search>
