<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2019%2F02%2F26%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[概念闭包 – 函数和声明该函数的词法环境的组合。 最简单的闭包： 12345678function A()&#123; function B()&#123; console.log('pyt'); &#125; return B;&#125;var C = A();C();// pyt 简单翻译一下这个函数：函数A的内部函数B被函数A外的一个变量C引用。 通俗一点理解：当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。 闭包大都返回一个函数，函数可以提供一个执行环境，在这个环境中引用其它环境的变量对象时，后者不会被js内部回收机制清除掉。 实例分析123456789101112131415function fun(n,o) &#123; console.log(o); return &#123; fun:function(m)&#123; return fun(m,n); &#125; &#125;;&#125;// firstvar a = fun(0); a.fun(1); a.fun(2); a.fun(3);//undefined,?,?,?// secondvar b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?// thirdvar c = fun(0).fun(1); c.fun(2); c.fun(3);//undefined,?,?,? 分析：first: 首先执行 a = fun(0) ,然后三次计算a.fun(1); a.fun(2); a.fun(3); 这三步并不是链式的，在第一次调用fun(0)后，得到：12345&#123; fun:function(m)&#123; return fun(m,n) &#125;&#125; 执行a.fun(1)，m = 1, n = 0 , 得到 fun(1,0), 打印出 0执行a.fun(2)，m = 2, n = 0 , 得到 fun(2,0), 打印出 0执行a.fun(3)，m = 3, n = 0 , 得到 fun(3,0), 打印出 0所以输出 undefined,0,0,0 second: 这个是链式调用，首先执行了 fun(0),得到：12345&#123; fun:function(m)&#123; return fun(m,0) &#125;&#125; 输出 undefined,再接着调用 .fun(1),返回：fun(1,0),输出 0,再调用 .fun(2),返回 fun(2,1),输出 1,再调用 .fun(3),返回 fun(3,2),输出 2最终输出 undefined,0,1,2 third: 首先执行 fun(0).fun(1),返回 fun(1,0),输出 undefined,0,后面两个不是链式的,所以执行 c.fun(2),返回 fun(2,1),输出 1,执行 c.fun(3),返回fun(3,1),输出 1最终输出 undefined,0,1,1 小结在 Javascript 中，如果一个对象不再被引用，那么这个对象就会被 GC 回收，否则这个对象一直会保存在内存中。 123456789101112function A() &#123; var count = 0; function B() &#123; count ++; console.log(count); &#125; return B;&#125;var C = A();C();// 1C();// 2C();// 3 因为定义了C，所以A中的count会一直保存在内存中, C每调用一次，B就会执行一次，count就会累加一次。 参考文章 JavaScript闭包 深入贯彻闭包思想，全面理解JS闭包形成过程 让你分分钟理解 JavaScript 闭包]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this,call,apply,bind]]></title>
    <url>%2F2019%2F01%2F22%2Fthis-call-apply-bind%2F</url>
    <content type="text"><![CDATA[thisthis 永远指向最后调用它的那个对象！！！ 1234567var love = 'football';function doSports() &#123; var love = 'basketball' console.log(`play $&#123;this.love&#125;`);&#125;// 前面没有调用的对象那么就是全局对象 windowdoSports(); // play football 123456789var love = 'football';var sports = &#123; love: 'basketball', do: function() &#123; console.log(`play $&#123;this.love&#125;`); &#125;&#125;// 通过对象sports调用sports.do(); // play basketball 123456789101112131415161718var love = 'football';var sports = &#123; love: 'basketball', do: function() &#123; console.log(`play $&#123;this.love&#125;`); &#125;&#125;// 通过对象sports调用sports.do(); // play basketball// this 永远指向最后调用它的那个对象// 最后调用的对象为sportswindow.sports.do(); // play basketball// sports.do并没有调用，只是将此方法赋值给变量spvar sp = sports.do;// sp方法直接使用，this指向全局的windowsp(); // play football apply、call在 javascript 中，call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部 this 的指向。 基本使用12345678910111213141516function sports(name) &#123; this.name = name; this.love = 'basketball'; this.do = function() &#123; console.log(`$&#123;this.name&#125; plays $&#123;this.love&#125;`); &#125; &#125; function player(name) &#123; sports.call(this,name); // 或者 // sports.apply(this,[name]); &#125; var James = new player('James'); James.do(); // James plays basketball 二者区别对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不一样。 123456var func = function(arg1, arg2) &#123; &#125;;func.call(this, arg1, arg2);func.apply(this, [arg1, arg2]); 其中 this 是你想指定的上下文，他可以是任何一个 JavaScript 对象(JavaScript 中一切皆对象)，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。 常用方法 数组合并 12345var arr1 = [1,2,3];var arr2 = [4,5,6];Array.prototype.push.apply(arr1,arr2);console.log(arr1); // [1, 2, 3, 4, 5, 6] 获取数字中最值 12345var arr = [3,1,-1,6,0];var mmax = Math.max.apply(Math,arr);console.log(mmax); var mmin = Math.min.apply(Math,arr);console.log(mmin); 类（伪）数组使用数组方法 1var domNodes = Array.prototype.slice.call(document.getElementsByTagName("*")); Javascript中存在一种名为伪数组的对象结构。比较特别的是 arguments 对象，还有像调用 getElementsByTagName , document.childNodes 之类的，它们返回NodeList对象都属于伪数组。不能应用 Array下的 push , pop 等方法。 但是我们能通过 Array.prototype.slice.call 转换为真正的数组的带有 length 属性的对象，这样 domNodes 就可以应用 Array 下的所有方法了。 自定义方法，如log 123456function log() &#123; var arr = Array.prototype.slice.call(arguments); arr.unshift('(swust)'); console.log.apply(console,arr);&#125;log("ni hao !"); // (swust) ni hao ! bindbind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 12345678910var obj =&#123; name : "pyt", do: function (a,b) &#123; console.log( a + b) &#125;&#125;var item = obj.do;// 使用 bind() ，后面多了对括号item.bind(obj,1,2)() // 3 注意：当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数 参考文章 this、apply、call、bind 深入浅出 妙用Javascript中apply、call、bind]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深拷贝 vs 浅拷贝]]></title>
    <url>%2F2019%2F01%2F12%2F%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[JavaScript的变量类型基本类型5种基本数据类型Undefined、Null、Boolean、Number 和 String，变量是直接按值存放的，存放在栈内存中的简单数据段，可以直接访问。 引用类型存放在堆内存中的对象，变量保存的是一个指针，这个指针指向另一个位置。当需要访问引用类型（如对象，数组等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。 浅拷贝（shallow copy） 最简单的浅拷贝，拷贝原对象的引用 123456789101112131415// 对象var o1 = &#123;a: 1&#125;;var o2 = o1;console.log(o1 === o2); // =&gt;trueo2.a = 2; console.log(o1.a); // =&gt; 2// 数组var o1 = [1,2,3];var o2 = o1;console.log(o1 === o2); // =&gt; trueo2.push(4);console.log(o1); // =&gt; [1,2,3,4] 拷贝原对象的实例，但是对其内部的引用类型值，拷贝的是其引用 常用的就是如jquey中的$.extend({}, obj)、Array.prototype.slice()和Array.prototype.concat()都会返回一个数组或者对象的浅拷贝 12345678910var o1 = ['pyt', &#123;age: 24&#125;];var o2 = o1.slice(); // 根据Array.prototype.slice()的特性，这里会返回一个o1的浅拷贝对象console.log(o1 === o2); // =&gt; false，说明o2拷贝的是o1的一个实例o2[0] = 'zxy';console.log(o1[0]); // =&gt; "pyt" o1和o2内部包含的基本类型值，复制的是其实例，不会相互影响o2[1].age = 23;console.log(o1[1].age); // =&gt;23 o1和o2内部包含的引用类型值，复制的是其引用，会相互影响 浅拷贝的简单实现 123456789101112function shallowClone(source) &#123; if (!source || typeof source !== 'object') &#123; throw new Error('error arguments'); &#125; var targetObj = source.constructor === Array ? [] : &#123;&#125;; for (var keys in source) &#123; if (source.hasOwnProperty(keys)) &#123; targetObj[keys] = source[keys]; &#125; &#125; return targetObj;&#125; 1234567891011121314151617181920212223242526272829// 第一层数据为基本数据类型var arrO1 = [1,2,3];var arrO2 = arrO1;arrO2[0] = 0;console.log(arrO1); // [0, 2, 3]var arrO3 = [1,2,3];var arrO4 = shallowClone(arrO3);arrO4[0] = 0;console.log(arrO3); // [1, 2, 3]// 原数据中包含子对象var obj1 = &#123; m: 1, n: [1,2,3]&#125;;var obj2 = obj1;obj2.m = 0;obj2.n[0] = 0;console.log(obj1); // &#123;m:0, n:[0,2,3]&#125;var obj3 = &#123; m: 1, n: [1,2,3]&#125;;var obj4 = shallowClone(obj3);obj4.m = 0;obj4.n[0] = 0;console.log(obj3); // &#123;m:1, n:[0,2,3]&#125; 深拷贝（deep copy）深拷贝就是拷贝出一个新的实例，新的实例和之前的实例互不影响。 递归实现深拷贝 1234567891011121314151617function deepClone(source)&#123; if(!source || typeof source !== 'object')&#123; throw new Error('error arguments', 'shallowClone'); &#125; var targetObj = source.constructor === Array ? [] : &#123;&#125;; for(var keys in source)&#123; if(source.hasOwnProperty(keys))&#123; if(source[keys] &amp;&amp; typeof source[keys] === 'object')&#123; targetObj[keys] = source[keys].constructor === Array ? [] : &#123;&#125;; targetObj[keys] = deepClone(source[keys]); &#125;else&#123; targetObj[keys] = source[keys]; &#125; &#125; &#125; return targetObj;&#125; 123456789101112131415161718192021222324252627282930var obj1 = &#123; m: 1, n: [1,2,3]&#125;;var obj2 = obj1;obj2.m = 0;obj2.n[0] = 0;console.log(obj1); // &#123;m:0, n:[0,2,3]&#125;var obj3 = &#123; m: 1, n: [1,2,3]&#125;;var obj4 = deepClone(obj3);obj4.m = 0;obj4.n[0] = 0;console.log(obj3); // &#123;m:1, n:[1,2,3]&#125;// 缺点： 无法对Date、正则表达式等特殊类型的拷贝var obj5 = &#123; arr: [111, 222], obj: &#123;key: '对象'&#125;, a: () =&gt; &#123;console.log('函数')&#125;, date: new Date(), reg: /正则/ig&#125;var obj6 = deepClone(obj5);console.log(obj6);// &#123;a:() =&gt; &#123;console.log('函数')&#125;, arr: [111,222], date: &#123;&#125;, obj: &#123;key: '对象'&#125;, reg: &#123;&#125;&#125; 利用JSON序列化实现深拷贝 利用JSON对象中的parse和stringify，JOSN对象中的stringify可以把一个js对象序列化为一个JSON字符串，parse可以把JSON字符串反序列化为一个js对象。缺点：在序列化JavaScript对象时，所有函数和原型成员会被有意忽略。 不能复制function、正则、Symbol 循环引用报错 相同的引用会被重复复制 12345678910111213function deepClone(source)&#123; return JSON.parse(JSON.stringify(source));&#125;var o1 = &#123; arr: [111, 222], obj: &#123;key: '对象'&#125;, a: () =&gt; &#123;console.log('函数')&#125;, date: new Date(), reg: /正则/ig&#125;;var o2 = deepClone(o1);console.log(o2); // &#123;arr: [111,222], date: "2019-01-22T03:31:51.999Z", obj: &#123;key: '对象'&#125;, reg: &#123;&#125;&#125; 其他方法 1234567891011**jquery**使用方法：let targetObj = $.extent(true,&#123;&#125;,sourceObj)**lodash函数库**使用方法：npm install lodash**es5写法**var lodash = require('lodash')**es6写法**import lodash from 'lodash'let targetOj = lodash.cloneDeep(sourceObj) 参考文章 js 深拷贝 vs 浅拷贝 JavaScript中的浅拷贝和深拷贝 JavaScript深拷贝的一些坑]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数组中常用的操作]]></title>
    <url>%2F2019%2F01%2F04%2FArray-in-JS%2F</url>
    <content type="text"><![CDATA[创建数组使用数组构造函数 var arr = new Array(); var arr = new Array(20); var arr = new Array(1,2,3); 使用数组字面量表示法 var arr = [1,2,3]; var arr2 = []; 数组操作push() , pop() 和 unshift() , shift()123var arr = [1,2,3];arr.push(4) // arr = [1, 2, 3, 4]var item = arr.pop() // item = 4 , arr = [1, 2, 3] 123var arr = [1,2,3];arr.unshift(4) // arr = [4, 1, 2, 3]var item = arr.shift() // item = 4 , arr = [1,2,3] 这两组同为对数组的操作，并且会改变数组的本身的长度及内容。 push()、pop() 是从数组的尾部进行增减，unshift()、shift() 是从数组的头部进行增减。 slice , splice array.slice(start,end) , 截取数组中的某段,并返回一个新的数组 12345678910111213141516171819202122var arr = [1,2,3,4,5];var a = arr.slice(0,3); // a = [1, 2, 3]var b =arr.slice(3); // b = [4, 5]// arr = [1, 2, 3, 4, 5]var a="i am a student";var b=a.slice(0,6); //"i am a"//如果两个参数中的任何一个是负数，array.length会和它们相加，试图让它们成为非负数，举例说明：//当只传入一个参数，且是负数时，length会与参数相加，然后再截取var a=[1,2,3,4,5,6];var b=a.slice(-1); //[6]//当只传入一个参数，是负数时,并且参数的绝对值大于数组length时，会截取整个数组var a=[1,2,3,4,5,6];var b=a.slice(-6); //[1,2,3,4,5,6]var c=a.slice(-8); //[1,2,3,4,5,6]//当传入两个参数一正一负时，length也会先于负数相加后，再截取var a=[1,2,3,4,5,6];var b=a.slice(2,-3); //[3]//当传入一个参数，大于length时，将返回一个空数组var a=[1,2,3,4,5,6];var b=a.slice(6); //[] delete 123var arr = ['a','b','c','d'];delete arr[1];console.log(arr) // ["a", undefined, "c", "d"] array.splice(start,deleteCount,item…) splice方法从array中移除一个或多个元素，并用新的item替换它们。参数start是从数组array中移除元素的开始位置。参数deleteCount是要移除的元素的个数。如果有额外的参数，那么item会插入到被移除元素的位置上。它返回一个包含被移除元素的数组。 12345678910111213141516171819var arr = ['aaa','bbb','ccc','ddd']var temp = arr.splice(1,1)console.log(arr) // ["aaa", "ccc", "ddd"]console.log(temp) // ["bbb"]var arr = ['aaa','bbb','ccc','ddd']var temp = arr.splice(1,0,'111')console.log(arr) // ["aaa", "111", "bbb", "ccc", "ddd"]console.log(temp) // []var arr = ['aaa','bbb','ccc','ddd']var temp = arr.splice(1,1,'222')console.log(arr) // ["aaa", "222", "ccc", "ddd"]console.log(temp) // ["bbb"]var arr = ['aaa','bbb','ccc','ddd']var temp = arr.splice(1,2,'333')console.log(arr) // ["aaa", "333", "ddd"]console.log(temp) // ["bbb", "ccc"] split 和 join string.split(separator,limit) split方法把这个string分割成片段来创建一个字符串数组。可选参数limit可以限制被分割的片段数量。separator参数可以是一个字符串或一个正则表达式。如果separator是一个空字符，会返回一个单字符的数组。 123var a = "0|1|2|3|456";var b = a.split("|",3); // b = ["0", "1", "2"]var c = a.split("|"); // c = ["0", "1", "2", "3", "456"] arrayObject.join(separator)12345var arr = ['swust','acm','306'];var str1 = arr.join(); // str1 = "swust,acm,306"var str2 = arr.join(""); // str2 = "swustacm306"var str3 = arr.join("-"); // str3 = "swust-acm-306"var str4 = "&lt;option&gt;" + arr.join("&lt;/option&gt;&lt;option&gt;")+ "&lt;/option&gt;"; // str4 = "&lt;option&gt;swust&lt;/option&gt;&lt;option&gt;acm&lt;/option&gt;&lt;option&gt;306&lt;/option&gt;" forEach , map , filter , reduce , ever , some forEach , 枚举数组中每一项 , 没有返回值 , 可以改变原数组 123456var arr = [2,7,8,10,11,13]var a = arr.forEach((item,index)=&gt; &#123; arr[index] = item + 2&#125;)console.log(arr) // [4, 9, 10, 12, 13, 15]console.log(a) // undefined map , 让数组每一项值进行计算后产生一个新数组 , 有返回值 123456var arr = [2,7,8,10,11,13]var k = arr.map((item,index)=&gt; &#123; return item + 2;&#125;)console.log(arr) // [2, 7, 8, 10, 11, 13]console.log(k) // [4, 9, 10, 12, 13, 15] filter , 筛选出数组中符合条件的项，组合成新数组 123456var arr = [2,7,8,10,11,13]var k = arr.filter((item,index)=&gt; &#123; return item &gt; 8;&#125;)console.log(arr) // [2, 7, 8, 10, 11, 13]console.log(k) // [10, 11, 13] reduce , 数组中前后项进行某种运算，并累计 123456var arr = [2,7,8,10,11,13]var k = arr.reduce((pre,next)=&gt; &#123; return pre + next;&#125;)console.log(arr) // [2, 7, 8, 10, 11, 13]console.log(k) // 51 every , 检测数组中是否每项都满足条件 123456var arr = [2,7,8,10,11,13]var k = arr.every((item,index)=&gt; &#123; return item &gt; 1;&#125;)console.log(arr) // [2, 7, 8, 10, 11, 13]console.log(k) // true some , 检测数组中是否有一项满足条件 123456var arr = [2,7,8,10,11,13]var k = arr.some((item,index)=&gt; &#123; return item &gt; 12;&#125;)console.log(arr) // [2, 7, 8, 10, 11, 13]console.log(k) // true]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[输入URL到页面完成加载]]></title>
    <url>%2F2018%2F10%2F18%2F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%AE%8C%E6%88%90%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[识别URL 浏览器通过URL获取请求信息: Protocol，使用哪种协议&quot;http&quot;/&quot;https&quot; Resource “/“,请求的资源是主页(index) 判断输入的信息是否为关键字 判断URL是否符合规则，进行相应编码处理 浏览器检查自带的“预加载 HSTS（HTTP严格传输安全）”列表 DNS查询 浏览器检查域名是否在DNS缓存当中 检查域名是否在本地Hosts文件里 向DNS服务器发送一条DNS查询请求 查询本地DNS服务器 查询根DNS服务器 查询顶级域名服务器 封装HTTP请求封装HTTP请求报文，包含请求方法、请求路径、请求主机、客户机类型、接受编码格式以及一些其他信息。123456GET / HTTP/1.1Host: zhihu.comUser-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64;Accept-Encoding: gzip, deflateConnection: Keep-Alive。` 服务器返回重定向(可能存在)返回状态码 301(永久性转移)或302(暂时性转移) 可以强制使用HTTPS(安全性) 防止网址劫持 多个网址，可能影响搜索引擎排名 建立连接 请求TCP套接字流，依次通过传输层(TCP segment)、网络层(IP packet)以及链路层(frame头部)进行数据封装 封包通过网络传输至服务器端 通过三次握手建立连接 服务器处理 通过路由寻址，服务器接收到请求后，在进入到真正的服务器前，可能还会经过负责负载均衡的服务器 负载均衡有基于硬件的 F5，有操作系统传输层(TCP)上的 LVS，也有在应用层(HTTP)实现的反向代理 进行很多统一处理，比如防攻击策略、防抓取、SSL、gzip、自动性能优化等 应用层的分流策略都能在这里做，比如对 /xx 路径的请求分到 a 服务器，对 /yy 路径的请求分到 b 服务器，或者按照 cookie 进行小流量测试等 缓存，并在后端服务挂掉的时候显示友好的 404 页面 监控后端服务是否异常 进入真正的服务器，处理请求，返回数据 浏览器处理数据 HTTP 请求返回的 HTML 传递到浏览器后，如果存在压缩，先解压，再编码 解析 —— HTML，CSS，JS 对 HTML 文档进行解析，生成解析树-&gt;以 DOM 元素以及属性为节点的树 根据CSS规则，分析CSS内容，生成样式表 渲染 —— 构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制 页面渲染，通过遍历DOM节点树，计算每个节点样式值，创建“渲染树” 使用GPU对某些图形样式进行渲染 参考 What really happens when you navigate to a URL 从输入 URL 到页面加载完成的过程中都发生了什么事情？ 在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？ 当···时发生了什么？]]></content>
  </entry>
  <entry>
    <title><![CDATA[URL中符号的作用]]></title>
    <url>%2F2018%2F10%2F17%2FURL%E4%B8%AD%E7%AC%A6%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[#的作用#的涵义 #代表网页中的一个位置。其右面的字符，就是该位置的标识符。 比如，http://www.xxx.com/a.html#action就代表网页a.html的action位置。浏览器读取这个URL后，会自动将action位置滚动至可视区域。 为网页位置指定标识符，有两个方法。一是使用锚点，比如&lt;a name=&quot;action&quot;&gt;&lt;/a&gt;，二是使用id属性，比如&lt;div id=&quot;action&quot;&gt; HTTP请求不包含#后的内容比如访问 -&gt; http://www.xxx.com/index.html#test ，实际请求 -&gt; http://www.xxx.com/index.html 在第一个#后出现的任何字符，都被当作位置标识符，比如想通过URL传参(颜色)如：http://www.xxx.com/?color=#fff,实际请求-&gt;http://www.xxx.com/?color=正确办法：http://www.xxx.com/?color=%23fff(将#转码为%23) 注意事项 改变#不触发网页重载，只会让浏览器滚动到相应位置 改变#会改变浏览器的访问历史（IE6/7除外） 可以windows.location.hash读取#值 当#值发生变化，会触发H5新增的onhashchange事件 Google抓取#的机制(参考) 默认情况下，Google的网络蜘蛛忽视URL的#部分。但是，Google还规定，如果你希望Ajax生成的内容被浏览引擎读取，那么URL中可以使用”#!”，Google会自动将其后面的内容转成查询字符串_escapedfragment的值。比如，Google发现新版twitter的URL：http://twitter.com/#!/username就会自动抓取另一个URL：http://twitter.com/?_escaped_fragment_=/username通过这种机制，Google就可以索引动态的Ajax内容。 ？的作用连接作用比如URL传参，http://www.xxx.com?page=1&amp;limit=10 清除缓存比如：http://www.xxx.com?index.html和http://www.xxx.com?index.html?3070 浏览器认为是不同的请求，就不会直接返回缓存的内容，而是重新读取 &amp;的作用间隔符。URL传参时，用于连接不同的参数。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端布局学习]]></title>
    <url>%2F2018%2F07%2F27%2F%E5%89%8D%E7%AB%AF%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[CSS盒模型通常情况下，被更多人认知的盒模型就是简单盒模型，简单盒模型在早期IE时期有一种怪异模式下的解析方式，也就是现在的 border-box ，后来W3C制定的标准以后规定在标准解析模式下使用标准盒模型 content-box 。 在标准模式下，一个块的总宽度= width + margin(左右) + padding(左右) + border(左右) 在怪异模式下，一个块的总宽度= width + margin(左右)（即width已经包含了padding和border值） CSS3新增属性：box-sizing,允许你以特定的方式定义匹配某个区域的特定元素。 当设置为box-sizing:content-box时，将采用标准模式解析计算，也是默认模式；当设置为box-sizing:border-box时，将采用怪异模式解析计算；123-webkit-box-sizing: content-box; /* Safari */-moz-box-sizing: content-box; /* Firefox */box-sizing: content-box|border-box|inherit; Flex布局Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 在 flex 容器中默认存在两条轴，水平主轴(main axis) 和垂直的交叉轴(cross axis) flex容器实现 flex 布局需要先指定一个容器，任何一个容器都可以被指定为 flex 布局，这样容器内部的元素就可以使用 flex 来进行布局 123.container &#123; display: flex | inline-flex; // 可以有两种取值&#125; 当时设置 flex 布局之后，子元素的 float、clear、vertical-align 的属性将会失效。 flex属性容器内属性 flex-direction 容器内项目的排列方向(默认横向排列) flex-wrap 容器内项目换行方式 flex-flow 以上两个属性的简写方式 justify-content 项目在主轴上的对齐方式 align-items 项目在交叉轴上如何对齐 align-content 定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 容器内项目属性 order 项目的排列顺序。数值越小，排列越靠前，默认为0。 flex-grow 项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 flex-shrink 项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 flex-basis 在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 flex 是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 align-self 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 可细读第一篇参考 居中问题在CSS布局中，经常会遇到居中的问题，诸如定长定宽或不定长宽的各类容器的居中。 水平居中 行内元素 要实现行内元素（&lt;span&gt;、&lt;a&gt;等）的水平居中，只需把行内元素包裹在块级父层元素（&lt;div&gt;、&lt;li&gt;、&lt;p&gt;等）中，并且在父层元素CSS设置如下： 123#container &#123; text-align:center;&#125; 块状元素 要实现块状元素（display:block）的水平居中，我们只需要将它的左右外边距margin-left和margin-right设置为auto 123#center &#123; margin:0 auto;&#125; 多个块状元素的水平居中 传统方法 将要水平排列的块状元素设为display:inline-block，然后在父级元素上设置text-align:center 1234567#container &#123; text-align:center;&#125; #center &#123; display:inline-block;&#125; Flexbox布局 要为元素设置flexbox布局，只需将display属性值设置为flex。 1234#container &#123; display: flex; justify-content: center;&#125; flexbox的默认为一个块级元素，如果需要定义为一个行内级的元素，同理： 123#container &#123; display: inline-flex;&#125; 水平垂直居中 已知高度宽度元素的水平垂直居中 绝对定位与负边距实现 1234567891011121314.container &#123; position: relative; height: 100vh;&#125;.center &#123; color: #fff; background-color: #000; width:100px; height: 100px; position: absolute; top:50%; left: 50%; margin: -50px 0 0 -50px;&#125; 绝对定位与margin 12345678910111213141516.container &#123; position: relative; height: 100vh;&#125;.center &#123; color: #fff; background-color: #000; width:100px; height: 100px; position: absolute; top: 0; bottom: 0; left: 0; right: 0; margin: auto;&#125; 未知高度和宽度元素的水平垂直居中 当要被居中的元素是inline或者inline-block元素 1234567891011.container &#123; width: 500px; height: 500px; display: table-cell; text-align: center; vertical-align: middle;&#125;.center &#123; color: #fff; background-color: #000;&#125; CSS3的transform 12345678910111213.container &#123; width: 500px; height: 500px; position: relative;&#125;.center &#123; color: #fff; background-color: #000; position: absolute; top: 50%; left: 50%; transform: (-50%,-50%);&#125; flex布局 1234567891011121314.container &#123; width: 500px; height: 500px; display: flex; justify-content: center; align-items: center;&#125;.center &#123; color: #fff; background-color: #000; /* width:100px; */ /* height: 100px; */&#125; 以上两种适用于被居中元素是块级或者非块级 常用布局模型单列布局 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;layout&lt;/title&gt; &lt;style type="text/css"&gt; body &#123; margin: 0; padding: 0; &#125; #header &#123; margin: 0 auto; max-width: 960px; height: 100px; background-color: #8080c0; &#125; #content &#123; margin: 0 auto; max-width: 960px; height: 400px; background-color: #00ffff; &#125; #footer &#123; margin: 0 auto; max-width: 960px; height: 100px; background-color: #8080c0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="header"&gt;头部&lt;/div&gt; &lt;div id="content"&gt;内容&lt;/div&gt; &lt;div id="footer"&gt;尾部&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 二&amp;三列布局 float+margin 设置两个侧栏分别向左向右浮动，中间列通过外边距给两个侧栏腾出空间，中间列的宽度根据浏览器窗口自适应。 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;layout&lt;/title&gt; &lt;style type="text/css"&gt; body &#123; margin: 0; padding: 0; &#125; #left &#123; float: left; width: 200px; height: 100vh; background-color: #8080ff; &#125; #right &#123; float: right; width: 300px; height: 100vh; background-color: #8080ff; &#125; #main &#123; margin: 0 300px 0 200px; height: 100vh; background-color: #00ffff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="left"&gt;left&lt;/div&gt; &lt;div id="right"&gt;right&lt;/div&gt; &lt;div id="main"&gt;main&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; position+margin 123456789101112131415161718192021#left &#123; position: absolute; top: 0; left: 0; width: 200px; height: 100vh; background-color: #8080ff;&#125;#right &#123; position: absolute; top: 0; right: 0; width: 300px; height: 100vh; background-color: #8080ff;&#125;#main &#123; margin: 0 300px 0 200px; height: 100vh; background-color: #00ffff;&#125; 圣杯布局(float + 负margin + padding + position) html代码中 main部分首先要放在container的最前部分。然后是left,right1.将三者都 float:left , 再加上一个position:relative (因为相对定位后面会用到） 2.main部分 width:100%占满 3.此时main占满了，所以要把left拉到最左边，使用margin-left:-100% 4.这时left拉回来了，但会覆盖main内容的左端，要把main内容拉出来，所以在外围container加上 padding:0 300px 0 200px 5.main内容拉回来了，但left也跟着过来了，所以要还原，就对left使用相对定位 left:-200px 同理，right也要相对定位还原 right:-300px 6.到这里大概就自适应好了。如果想container高度保持一致可以给left main right都加上min-height:130px 备注： 参考(https://www.cnblogs.com/imwtr/p/4441741.html) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;layout&lt;/title&gt; &lt;style type="text/css"&gt; body &#123; margin: 0; padding: 0; &#125; #container &#123; padding: 0 300px 0 200px; &#125; #left &#123; float: left; position: relative; margin-left: -100%; left: -200px; width: 200px; height: 100vh; background-color: #8080ff; &#125; #right &#123; float: left; position: relative; margin-left: -300px; right: -300px; width: 300px; height: 100vh; background-color: #8080ff; &#125; #main &#123; float: left; position: relative; width: 100%; height: 100vh; background-color: #00ffff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="container"&gt; &lt;div id="main"&gt;main&lt;/div&gt; &lt;div id="left"&gt;left&lt;/div&gt; &lt;div id="right"&gt;right&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 双飞翼布局(float + 负margin + margin) 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;layout&lt;/title&gt; &lt;style type="text/css"&gt; body &#123; margin: 0; padding: 0; &#125; #inner_main &#123; margin: 0 300px 0 200px; &#125; #left &#123; float: left; margin-left: -100%; width: 200px; height: 100vh; background-color: #8080ff; &#125; #right &#123; float: left; margin-left: -300px; width: 300px; height: 100vh; background-color: #8080ff; &#125; #main &#123; float: left; width: 100%; height: 100vh; background-color: #00ffff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="main"&gt; &lt;div id="inner_main"&gt; main &lt;/div&gt; &lt;/div&gt; &lt;div id="left"&gt;left&lt;/div&gt; &lt;div id="right"&gt;right&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 备注： 以上两种布局有点难理解 flex布局 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;layout&lt;/title&gt; &lt;style type="text/css"&gt; body &#123; margin: 0; padding: 0; &#125; .layout &#123; display: flex; /* 便于观测，设置间隔 */ margin-bottom: 10px; &#125; .layout__main &#123; flex: 1; background-color: aqua; &#125; .layout__aside &#123; width: 200px; background-color: bisque; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="layout"&gt; &lt;aside class="layout__aside"&gt;侧边栏宽度固定&lt;/aside&gt; &lt;div class="layout__main"&gt;主内容栏宽度自适应&lt;/div&gt; &lt;/div&gt; &lt;div class="layout"&gt; &lt;div class="layout__main"&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class="layout__aside"&gt;侧边栏宽度固定&lt;/aside&gt; &lt;/div&gt; &lt;div class="layout"&gt; &lt;aside class="layout__aside"&gt;左侧边栏宽度固定&lt;/aside&gt; &lt;div class="layout__main"&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class="layout__aside"&gt;右侧边栏宽度固定&lt;/aside&gt; &lt;/div&gt; &lt;div class="layout"&gt; &lt;aside class="layout__aside"&gt;第1个侧边栏宽度固定&lt;/aside&gt; &lt;aside class="layout__aside"&gt;第2个侧边栏宽度固定&lt;/aside&gt; &lt;div class="layout__main"&gt;主内容栏宽度自适应&lt;/div&gt; &lt;/div&gt; &lt;div class="layout"&gt; &lt;div class="layout__main"&gt;主内容栏宽度自适应&lt;/div&gt; &lt;aside class="layout__aside"&gt;第1个侧边栏宽度固定&lt;/aside&gt; &lt;aside class="layout__aside"&gt;第2个侧边栏宽度固定&lt;/aside&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; flex除了兼容性，用起来真的舒服… 参考 Flex 布局教程：语法篇 Flex 布局教程：实例篇 30 分钟学会 Flex 布局 最全面的水平垂直居中方案与flexbox布局 CSS布局十八般武艺都在这里了]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swiper基础学习]]></title>
    <url>%2F2018%2F07%2F24%2Fswiper%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[简介Swiper(Swiper master)是目前应用较广泛的移动端网页触摸内容滑动js插件 官方介绍： Swiper常用于移动端网站的内容触摸滑动 Swiper是纯javascript打造的滑动特效插件，面向手机、平板电脑等移动终端。Swiper能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果。Swiper开源、免费、稳定、使用简单、功能强大，是架构移动终端网站的重要选择！ Swiper拥有灵活的progress，这是自定义制作3D切换效果的利器 Swiper制作3D切换效果的方法多种多样。cube、coverflow和flip可以轻松的实现3D过渡，如果你想制作其他新颖的切换方式，推荐使用progress。progress可以帮助你获取到滑块的进度索引。 在Swiper上加些小动画，制作时下最流行的微展示 使用Swiper再配合一些你喜欢的小动画，你的图片立即变成活灵活现的微场景、微海报。常用的制作动画的方法有CSS3、TweenMax、animate.css等。也推荐使用我们的Swiper Animate小插件，无需学习即可快速制作出精美的切换动画效果。 使用普通使用引入swiper.min.css与swiper.min.js直接上代码，详情见注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;swiper简单学习&lt;/title&gt; &lt;link rel="stylesheet" href="./swiper.min.css"&gt; &lt;style&gt; body &#123; background-color: #000; &#125; .swiper-container &#123; width: 100%; height: 200px; &#125; .swiper-slide &#123; background-size: 100%; background-repeat: no-repeat; &#125; h3 &#123; width: 70%; color: #fff; text-align: right; position: absolute; right: 5%; bottom: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="swiper-container"&gt; &lt;div class="swiper-wrapper"&gt; &lt;div onclick="alert(1)" class="swiper-slide" style="background-image: url(./img/1.png)"&gt; &lt;h3&gt;我的心里有个梦,想去嵩山少林学武功&lt;/h3&gt; &lt;/div&gt; &lt;div onclick="alert(2)" class="swiper-slide" style="background-image: url(./img/2.png)"&gt; &lt;h3&gt;我的心里有个梦,想去嵩山少林学武功&lt;/h3&gt; &lt;/div&gt; &lt;div onclick="alert(3)" class="swiper-slide" style="background-image: url(./img/3.png)"&gt; &lt;h3&gt;我的心里有个梦,想去嵩山少林学武功&lt;/h3&gt; &lt;/div&gt; &lt;div onclick="alert(4)" class="swiper-slide" style="background-image: url(./img/4.png)"&gt; &lt;h3&gt;我的心里有个梦,想去嵩山少林学武功&lt;/h3&gt; &lt;/div&gt; &lt;div onclick="alert(5)" class="swiper-slide" style="background-image: url(./img/5.png)"&gt; &lt;h3&gt;我的心里有个梦,想去嵩山少林学武功&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 如果需要分页器 --&gt; &lt;div class="swiper-pagination"&gt;&lt;/div&gt; &lt;!-- 如果需要导航按钮 --&gt; &lt;!-- &lt;div class="swiper-button-prev"&gt;&lt;/div&gt; &lt;div class="swiper-button-next"&gt;&lt;/div&gt; --&gt; &lt;!-- 如果需要滚动条 --&gt; &lt;!-- &lt;div class="swiper-scrollbar"&gt;&lt;/div&gt; --&gt; &lt;/div&gt; &lt;script src="./swiper.min.js"&gt;&lt;/script&gt; &lt;script&gt; var mySwiper = new Swiper('.swiper-container', &#123; direction: 'horizontal', loop: true, effect: 'fade', // 切换效果 autoplay: &#123; // 自动切换，默认3秒 disableOnInteraction: false, // 用户操作swiper之后自动切换不会停止 &#125;, // 如果需要分页器 pagination: &#123; el: '.swiper-pagination', &#125;, // 如果需要前进后退按钮 navigation: &#123; nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev', &#125;, // 如果需要滚动条 scrollbar: &#123; el: '.swiper-scrollbar', &#125;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果： Vue组件 引入Swiper npm install --save swiper 父页面 在模板中设置轮播图的html布局。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;template&gt; &lt;m-swipe swipeid="swipe" ref="swiper" :autoPlay="true" effect="slide"&gt; &lt;div v-for="top in tops" :key="top.id" class="swiper-slide" slot="swiper-con"&gt; &lt;img :src="top.img"&gt; &lt;h3&gt;&#123;&#123;top.title&#125;&#125;&lt;/h3&gt; &lt;/div&gt; &lt;/m-swipe&gt;&lt;/template&gt;&lt;script&gt; import Swiper from './swiper/swiper' export default &#123; components: &#123; "m-swipe": Swiper &#125;, data() &#123; return &#123; tops: [&#123; "id": 1, "img": "../../static/img/1.png", "title": "我心里有个梦，想去嵩山少林学武功" &#125;, &#123; "id": 2, "img": "../../static/img/2.png", "title": "我心里有个梦，想去嵩山少林学武功" &#125;, &#123; "id": 3, "img": "../../static/img/3.png", "title": "我心里有个梦，想去嵩山少林学武功" &#125;, &#123; "id": 4, "img": "../../static/img/4.png", "title": "我心里有个梦，想去嵩山少林学武功" &#125;, &#123; "id": 5, "img": "../../static/img/5.png", "title": "我心里有个梦，想去嵩山少林学武功" &#125; ] &#125; &#125; &#125;&lt;/script&gt;&lt;style lang="less" scoped&gt; @blue: #5b7492; @yellow: #ffd300; @gray: #acb9c8; .app-view &#123; .swiper-container &#123; width: 100%; &#125; .swiper-slide &#123; height: 10rem; overflow: hidden; position: relative; &#125; &#125; .swiper-slide &#123; div &#123; top: 0; left: 0; width: 100%; height: 100%; opacity: 0.4; position: absolute; background-color: @blue; &#125; img &#123; width: 100%; // top: 50%; // position: relative; // transform: translate(0, -50%); &#125; h3 &#123; width: 70%; color: #fff; margin: 0; font-size: 1rem; line-height: 1rem; right: 5%; bottom: 2.6rem; text-align: right; position: absolute; text-shadow: 1px 1px 10px rgba(0, 0, 0, 0.5); &amp;:before &#123; content: ""; width: 3rem; bottom: -0.6rem; right: 0; display: block; position: absolute; border: 2px solid @yellow; &#125; &#125; &#125;&lt;/style&gt; 其中使用具名插槽，提高解耦，使得在父组件使用时，根据不同情况，设置不同的轮播内容。 另外需要设置分页器，即图片轮播中的页面指示器，常见的如小圆点，或者数字指示器。 swiper.vue组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;template&gt; &lt;div class="swiper-container" :class="swipeid"&gt; &lt;div class="swiper-wrapper"&gt; &lt;!-- 存放具体的轮播内容 --&gt; &lt;slot name="swiper-con"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;!-- 分页器 --&gt; &lt;div :class="&#123;'swiper-pagination':pagination&#125;"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Swiper from "swiper"; import "swiper/dist/css/swiper.min.css"; export default &#123; props: &#123; swipeid: &#123; type: String, default: "" &#125;, effect: &#123; type: String, default: "slide" &#125;, loop: &#123; type: Boolean, default: false &#125;, direction: &#123; type: String, default: "horizontal" &#125;, pagination: &#123; type: Boolean, default: true &#125;, paginationType: &#123; type: String, default: "bullets" &#125;, autoPlay: &#123; type: Boolean, default: true &#125; &#125;, data() &#123; return &#123; dom: "" &#125;; &#125;, mounted() &#123; var that = this; this.dom = new Swiper("." + that.swipeid, &#123; //循环 loop: that.loop, //分页器 pagination: &#123; el: ".swiper-pagination", bulletClass: 'swiper-pagination-bullet', &#125;, //分页类型 paginationType: that.paginationType, //自动播放 autoplay: that.autoPlay, //方向 direction: that.direction, //特效 effect: that.effect, //用户操作swiper之后，不禁止autoplay disableOnInteraction: false, //修改swiper自己或子元素时，自动初始化swiper observer: true, //修改swiper的父元素时，自动初始化swiper observeParents: true &#125;); &#125; &#125;;&lt;/script&gt;&lt;style&gt; .swiper-pagination-bullet-active &#123; background: #fff; &#125; .swiper-container-horizontal&gt;.swiper-pagination-bullets &#123; bottom: 1rem; width: 95%; text-align: right; &#125;&lt;/style&gt; 效果 疑问 vue中assets和static的区别 Webpacked Assets 我们首先需要了解Webpack如何处理静态资产。在 *.vue 组件中，所有模板和CSS都会被 vue-html-loader 及 css-loader 解析，并查找资源URL。例如，在 &lt;img src=&quot;./logo.png&quot;&gt;和 background: url(./logo.png) 中，”./logo.png“ 是相对的资源路径，将由Webpack解析为模块依赖。因为 logo.png 不是 JavaScript，当被视为模块依赖时，需要使用 url-loader 和 file-loader处理它。vue-cli 的 webpack 脚手架已经配置了这些 loader，因此可以使用相对/模块路径。由于这些资源可能在构建过程中被内联/复制/重命名，所以它们基本上是源代码的一部分。这就是为什么建议将Webpack 处理的静态资源放在 /src 目录中和其它源文件放一起的原因。事实上，甚至不必把它们全部放在 /src/assets：可以用模块/组件的组织方式来使用它们。例如，可以在每个放置组件的目录中存放静态资源。 “Real” Static Assets 相比之下，static/ 目录下的文件并不会被 Webpack 处理：它们会直接被复制到最终目录（默认是dist/static）下。必须使用绝对路径引用这些文件，这是通过在 config.js 文件中的 build.assetsPublicPath 和 build.assetsSubDirectory 连接来确定的。 任何放在 static/ 中文件需要以绝对路径的形式引用：/static/[filename]。如果更改 assetSubDirectory 的值为 assets，那么路径需改为 /assets/[filename]。 答案来源：https://segmentfault.com/q/1010000009842688 Vue.js 如何正确引用图片地址? 放在模版里是会被 webpack 打包出来 所以可以而在 js 里写图片路径其实只是字符串 webpack 不会处理如果想这么做 你可以把图片放在最外层的 static 文件夹或使用 import require 引入 答案来源：https://segmentfault.com/q/1010000007930232 参考 Swiper中文网 Vue封装Swiper实现图片轮播]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>swiper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[(转)理解 JavaScript 作用域]]></title>
    <url>%2F2018%2F07%2F24%2Fjs%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[简介JavaScript 有个特性称为作用域。尽管对于很多开发新手来说，作用域的概念不容易理解，我会尽可能地从最简单的角度向你解释它们。理解作用域能让你编写更优雅、错误更少的代码，并能帮助你实现强大的设计模式。 什么是作用域作用域是你的代码在运行时，各个变量、函数和对象的可访问性。换句话说，作用域决定了你的代码里的变量和其他资源在各个区域中的可见性。 为什么需要作用域？最小访问原则那么，限制变量的可见性，不允许你代码中所有的东西在任意地方都可用的好处是什么？其中一个优势，是作用域为你的代码提供了一个安全层级。计算机安全中，有个常规的原则是：用户只能访问他们当前需要的东西。 想想计算机管理员吧。他们在公司各个系统上拥有很多控制权，看起来甚至可以给予他们拥有全部权限的账号。假设你有一家公司，拥有三个管理员，他们都有系统的全部访问权限，并且一切运转正常。但是突然发生了一点意外，你的一个系统遭到恶意病毒攻击。现在你不知道这谁出的问题了吧？你这才意识到你应该只给他们基本用户的账号，并且只在需要时赋予他们完全的访问权。这能帮助你跟踪变化并记录每个人的操作。这叫做最小访问原则。眼熟吗？这个原则也应用于编程语言设计，在大多数编程语言（包括 JavaScript）中称为作用域，接下来我们就要学习它。 在你的编程旅途中，你会意识到作用域在你的代码中可以提升性能，跟踪 bug 并减少 bug。作用域还解决不同范围的同名变量命名问题。记住不要弄混作用域和上下文。它们是不同的特性。 JavaScript中的作用域在 JavaScript 中有两种作用域 全局作用域 局部作用域 当变量定义在一个函数中时，变量就在局部作用域中，而定义在函数之外的变量则从属于全局作用域。每个函数在调用的时候会创建一个新的作用域。 全局作用域当你在文档中（document）编写 JavaScript 时，你就已经在全局作用域中了。JavaScript 文档中（document）只有一个全局作用域。定义在函数之外的变量会被保存在全局作用域中。 12// the scope is by default globalvar name = 'Hammad'; 全局作用域里的变量能够在其他作用域中被访问和修改。 123456789var name = 'Hammad'; console.log(name); // logs 'Hammad' function logName() &#123; console.log(name); // 'name' is accessible here and everywhere else&#125; logName(); // logs 'Hammad' 局部作用域定义在函数中的变量就在局部作用域中。并且函数在每次调用时都有一个不同的作用域。这意味着同名变量可以用在不同的函数中。因为这些变量绑定在不同的函数中，拥有不同作用域，彼此之间不能访问。 12345678910111213// Global Scopefunction someFunction() &#123; // Local Scope ##1 function someOtherFunction() &#123; // Local Scope ##2 &#125;&#125; // Global Scopefunction anotherFunction() &#123; // Local Scope ##3&#125;// Global Scope 块语句块级声明包括if和switch，以及for和while循环，和函数不同，它们不会创建新的作用域。在块级声明中定义的变量从属于该块所在的作用域。 123456if (true) &#123; // this 'if' conditional block doesn't create a new scope var name = 'Hammad'; // name is still in the global scope&#125; console.log(name); // logs 'Hammad' ECMAScript 6 引入了let和const关键字。这些关键字可以代替var。 1234var name = 'Hammad'; let likes = 'Coding';const skills = 'Javascript and PHP'; 和var关键字不同，let和const关键字支持在块级声明中创建使用局部作用域。 1234567891011121314if (true) &#123; // this 'if' conditional block doesn't create a scope // name is in the global scope because of the 'var' keyword var name = 'Hammad'; // likes is in the local scope because of the 'let' keyword let likes = 'Coding'; // skills is in the local scope because of the 'const' keyword const skills = 'JavaScript and PHP';&#125; console.log(name); // logs 'Hammad'console.log(likes); // Uncaught ReferenceError: likes is not definedconsole.log(skills); // Uncaught ReferenceError: skills is not defined 一个应用中全局作用域的生存周期与该应用相同。局部作用域只在该函数调用执行期间存在。 上下文很多开发者经常弄混作用域和上下文，似乎两者是一个概念。但并非如此。作用域是我们上面讲到的那些，而上下文通常涉及到你代码某些特殊部分中的this值。作用域指的是变量的可见性，而上下文指的是在相同的作用域中的this的值。我们当然也可以使用函数方法改变上下文，这个之后我们再讨论。在全局作用域中，上下文总是 Window 对象。 123456789// logs: Window &#123;speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage…&#125;console.log(this); function logFunction() &#123; console.log(this);&#125;// logs: Window &#123;speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage…&#125;// because logFunction() is not a property of an objectlogFunction(); 如果作用域定义在一个对象的方法中，上下文就是这个方法所在的那个对象。 1234567class User &#123; logName() &#123; console.log(this); &#125;&#125; (new User).logName(); // logs User &#123;&#125; (new User).logName()是创建对象关联到变量并调用logName方法的一种简便形式。通过这种方式你并不需要创建一个新的变量。 你可能注意到一点，就是如果你使用new关键字调用函数时上下文的值会有差异。上下文会设置为被调用的函数的实例。考虑一下上面的这个例子，用new关键字调用的函数。 12345function logFunction() &#123; console.log(this);&#125; new logFunction(); // logs logFunction &#123;&#125; 当在严格模式（strict mode）中调用函数时，上下文默认是 undefined。 执行环境为了解决掉我们从上面学习中会出现的各种困惑，“执行环境（context）”这个词中的“环境（context）”指的是作用域而并非上下文。这是一个怪异的命名约定，但由于 JavaScript 的文档如此，我们只好也这样约定。 JavaScript 是一种单线程语言，所以它同一时间只能执行单个任务。其他任务排列在执行环境中。当 JavaScript 解析器开始执行你的代码，环境（作用域）默认设为全局。全局环境添加到你的执行环境中，事实上这是执行环境里的第一个环境。 之后，每个函数调用都会添加它的环境到执行环境中。无论是函数内部还是其他地方调用函数，都会是相同的过程。 每个函数都会创建它自己的执行环境。 当浏览器执行完环境中的代码，这个环境会从执行环境中弹出，执行环境中当前环境的状态会转移到父级环境。浏览器总是先执行在执行栈顶的执行环境（事实上就是你代码最里层的作用域）。 全局环境只能有一个，函数环境可以有任意多个。执行环境有两个阶段：创建和执行。 创建阶段第一阶段是创建阶段，是函数刚被调用但代码并未执行的时候。创建阶段主要发生了 3 件事。 创建变量对象 创建作用域链 设置上下文（this）的值 变量对象变量对象（Variable Object）也称为活动对象（activation object），包含所有变量、函数和其他在执行环境中定义的声明。当函数调用时，解析器扫描所有资源，包括函数参数、变量和其他声明。当所有东西装填进一个对象，这个对象就是变量对象。 123'variableObject': &#123; // contains function arguments, inner variable and function declarations&#125; 作用域链在执行环境创建阶段，作用域链在变量对象之后创建。作用域链包含变量对象。作用域链用于解析变量。当解析一个变量时，JavaScript 开始从最内层沿着父级寻找所需的变量或其他资源。作用域链包含自己执行环境以及所有父级环境中包含的变量对象。 123'scopeChain': &#123; // contains its own variable object and other variable objects of the parent execution contexts&#125; 执行环境对象执行环境可以用下面抽象对象表示： 12345executionContextObject = &#123; 'scopeChain': &#123;&#125;, // contains its own variableObject and other variableObject of the parent execution contexts 'variableObject': &#123;&#125;, // contains function arguments, inner variable and function declarations 'this': valueOfThis&#125; 代码执行阶段执行环境的第二个阶段就是代码执行阶段，进行其他赋值操作并且代码最终被执行。 词法作用域词法作用域的意思是在函数嵌套中，内层函数可以访问父级作用域的变量等资源。这意味着子函数词法绑定到了父级执行环境。词法作用域有时和静态作用域有关。 12345678910111213function grandfather() &#123; var name = 'Hammad'; // likes is not accessible here function parent() &#123; // name is accessible here // likes is not accessible here function child() &#123; // Innermost level of the scope chain // name is also accessible here var likes = 'Coding'; &#125; &#125;&#125; 你可能注意到了词法作用域是向前的，意思是子执行环境可以访问name。但不是由父级向后的，意味着父级不能访问likes。这也告诉了我们，在不同执行环境中同名变量优先级在执行栈由上到下增加。一个变量和另一个变量同名，内层函数（执行栈顶的环境）有更高的优先级。 闭包闭包的概念和我们刚学习的词法作用域紧密相关。当内部函数试着访问外部函数的作用域链（词法作用域之外的变量）时产生闭包。闭包包括它们自己的作用域链、父级作用域链和全局作用域。 闭包不仅能访问外部函数的变量，也能访问外部函数的参数。 即使函数已经return，闭包仍然能访问外部函数的变量。这意味着return的函数允许持续访问外部函数的所有资源。 当你的外部函数return一个内部函数，调用外部函数时return的函数并不会被调用。你必须先用一个单独的变量保存外部函数的调用，然后将这个变量当做函数来调用。看下面这个例子： 1234567891011121314function greet() &#123; name = 'Hammad'; return function () &#123; console.log('Hi ' + name); &#125;&#125; greet(); // nothing happens, no errors // the returned function from greet() gets saved in greetLettergreetLetter = greet(); // calling greetLetter calls the returned function from the greet() functiongreetLetter(); // logs 'Hi Hammad' 值得注意的是，即使在greet函数return后，greetLetter函数仍可以访问greet函数的name变量。如果不使用变量赋值来调用greet函数return的函数，一种方法是使用()两次()()，如下所示： 12345678function greet() &#123; name = 'Hammad'; return function () &#123; console.log('Hi ' + name); &#125;&#125; greet()(); // logs 'Hi Hammad' 共有作用域和私有作用域在许多其他编程语言中，你可以通过 public、private 和 protected 作用域来设置类中变量和方法的可见性。看下面这个 PHP 的例子 1234567891011121314151617// Public Scopepublic $property;public function method() &#123; // ...&#125; // Private Sccpeprivate $property;private function method() &#123; // ...&#125; // Protected Scopeprotected $property;protected function method() &#123; // ...&#125; 将函数从公有（全局）作用域中封装，使它们免受攻击。但在 JavaScript 中，没有 共有作用域和私有作用域。然而我们可以用闭包实现这一特性。为了使每个函数从全局中分离出去，我们要将它们封装进如下所示的函数中： 123(function () &#123; // private scope&#125;)(); 函数结尾的括号告诉解析器立即执行此函数。我们可以在其中加入变量和函数，外部无法访问。但如果我们想在外部访问它们，也就是说我们希望它们一部分是公开的，一部分是私有的。我们可以使用闭包的一种形式，称为模块模式（Module Pattern），它允许我们用一个对象中的公有作用域和私有作用域来划分函数。 模块模式模块模式如下所示： 1234567891011var Module = (function() &#123; function privateMethod() &#123; // do something &#125; return &#123; publicMethod: function() &#123; // can call privateMethod(); &#125; &#125;;&#125;)(); Module 的return语句包含了我们的公共函数。私有函数并没有被return。函数没有被return确保了它们在 Module 命名空间无法访问。但我们的共有函数可以访问我们的私有函数，方便它们使用有用的函数、AJAX 调用或其他东西。 12Module.publicMethod(); // worksModule.privateMethod(); // Uncaught ReferenceError: privateMethod is not defined 一种习惯是以下划线作为开始命名私有函数，并返回包含共有函数的匿名对象。这使它们在很长的对象中很容易被管理。向下面这样： 1234567891011var Module = (function () &#123; function _privateMethod() &#123; // do something &#125; function publicMethod() &#123; // do something &#125; return &#123; publicMethod: publicMethod, &#125;&#125;)(); 立即执行函数表达式（IIFE）另一种形式的闭包是立即执行函数表达式（Immediately-Invoked Function Expression，IIFE）。这是一种在 window 上下文中自调用的匿名函数，也就是说this的值是window。它暴露了一个单一全局接口用来交互。如下所示： 123(function(window) &#123; // do anything&#125;)(this); 使用 .call()， .apply() 和 .bind() 改变上下文Call 和 Apply 函数来改变函数调用时的上下文。这带给你神奇的编程能力（和终极统治世界的能力）。你只需要使用 call 和 apply 函数并把上下文当做第一个参数传入，而不是使用括号来调用函数。函数自己的参数可以在上下文后面传入。 1234567function hello() &#123; // do something...&#125;hello(); // the way you usually call ithello.call(context); // here you can pass the context(value of this) as the first argumenthello.apply(context); // here you can pass the context(value of this) as the first argument .call()和.apply()的区别是 Call 中其他参数用逗号分隔传入，而 Apply 允许你传入一个参数数组。 12345678910111213141516function introduce(name, interest) &#123; console.log('Hi! I'm '+ name +' and I like '+ interest +'.'); console.log('The value of this is '+ this +'.')&#125; introduce('Hammad', 'Coding'); // the way you usually call itintroduce.call(window, 'Batman', 'to save Gotham'); // pass the arguments one by one after the contexttintroduce.apply('Hi', ['Bruce Wayne', 'businesses']); // pass the arguments in an array after the context // Output:// Hi! I'm Hammad and I like Coding.// The value of this is [object Window].// Hi! I'm Batman and I like to save Gotham.// The value of this is [object Window].// Hi! I'm Bruce Wayne and I like businesses.// The value of this is Hi. Call 比 Apply 的效率高一点。 下面这个例子列举文档中所有项目，然后依次在控制台打印出来。 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Things to learn&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Things to Learn to Rule the World&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Learn PHP&lt;/li&gt; &lt;li&gt;Learn Laravel&lt;/li&gt; &lt;li&gt;Learn JavaScript&lt;/li&gt; &lt;li&gt;Learn VueJS&lt;/li&gt; &lt;li&gt;Learn CLI&lt;/li&gt; &lt;li&gt;Learn Git&lt;/li&gt; &lt;li&gt;Learn Astral Projection&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // Saves a NodeList of all list items on the page in listItems var listItems = document.querySelectorAll('ul li'); // Loops through each of the Node in the listItems NodeList and logs its content for (var i = 0; i &lt; listItems.length; i++) &#123; (function () &#123; console.log(this.innerHTML); &#125;).call(listItems[i]); &#125; // Output logs: // Learn PHP // Learn Laravel // Learn JavaScript // Learn VueJS // Learn CLI // Learn Git // Learn Astral Projection &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML文档中仅包含一个无序列表。JavaScript 从 DOM 中选取它们。列表项会被从头到尾循环一遍。在循环时，我们把列表项的内容输出到控制台。 输出语句包含在由括号包裹的函数中，然后调用call函数。相应的列表项传入 call 函数，确保控制台输出正确对象的 innerHTML。 对象可以有方法，同样函数对象也可以有方法。事实上，JavaScript 函数有 4 个内置方法： Function.prototype.apply() Function.prototype.bind() (Introduced in ECMAScript 5 (ES5)) Function.prototype.call() Function.prototype.toString() Function.prototype.toString()返回函数代码的字符串表示。 到现在为止，我们讨论了.call()、.apply()和toString()。与 Call 和 Apply 不同，Bind 并不是自己调用函数，它只是在函数调用之前绑定上下文和其他参数。在上面提到的例子中使用 Bind： 12345678(function introduce(name, interest) &#123; console.log('Hi! I'm '+ name +' and I like '+ interest +'.'); console.log('The value of this is '+ this +'.')&#125;).bind(window, 'Hammad', 'Cosmology')(); // logs:// Hi! I'm Hammad and I like Cosmology.// The value of this is [object Window]. Bind 像call函数一样用逗号分隔其他传入参数，不像apply那样用数组传入参数。 完 转自前端大全，编译：伯乐在线/孙腾浩]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios.js学习]]></title>
    <url>%2F2018%2F07%2F18%2FAxios-js%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[简介Promise based HTTP client for the browser and node.jsaxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 特征： 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 安装：12345npm install axiosorbower install axiosor&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 样例执行GET请求 1234567891011121314151617181920212223242526272829303132333435363738394041const axios = require('axios');// Make a request for a user with a given IDaxios.get('/user?ID=12345') .then(function (response) &#123; // handle success console.log(response); &#125;) .catch(function (error) &#123; // handle error console.log(error); &#125;) .then(function () &#123; // always executed &#125;);// Optionally the request above could also be done asaxios.get('/user', &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;) .then(function () &#123; // always executed &#125;); // Want to use async/await? Add the `async` keyword to your outer function/method.async function getUser() &#123; try &#123; const response = await axios.get('/user?ID=12345'); console.log(response); &#125; catch (error) &#123; console.error(error); &#125;&#125; 提示：async/await 是ES7中的一部分，在Internet Explorer和老版本版浏览器中不支持，因此请谨慎使用。 执行POST请求 12345678910axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行多个并发请求 123456789101112function getUserAccount() &#123; return axios.get('/user/12345');&#125;function getUserPermissions() &#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // Both requests are now complete &#125;)); 配置普通配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import axios from 'axios' //引用axiosimport &#123;Promise&#125; from 'es6-promise' //引入Promise// axios 配置axios.defaults.timeout = 5000; //设置超时时间axios.defaults.baseURL = 'http://localhost:4000/api/v1/'; //这是调用数据接口// http request 拦截器（所有发送的请求都要从这儿过一次），通过这个，我们就可以把token传到后台，我这里是使用sessionStorage来存储token等权限信息和用户信息，若要使用cookie可以自己封装一个函数并import便可使用axios.interceptors.request.use( config =&gt; &#123; const token = sessionStorage.getItem("token"); //获取存储在本地的token config.data = JSON.stringify(config.data); config.headers = &#123; 'Content-Type':'application/json' //设置跨域头部,虽然很多浏览器默认都是使用json传数据，但咱要考虑IE浏览器。 &#125;; if (token) &#123; config.headers.Authorization = "Token " + token; //携带权限参数 &#125; return config; &#125;, err =&gt; &#123; return Promise.reject(err); &#125;);// http response 拦截器（所有接收到的请求都要从这儿过一次）axios.interceptors.response.use( response =&gt; &#123;//response.status===401是我和后台约定的权限丢失或者权限不够返回的状态码，这个可以自己和后台约定，约定返回某个自定义字段也是可以的 if(response.status == 401) &#123; router.push(&#123; //push后面是一个参数对象，可以携带很多参数，具体可以去vue-router上查看，例如query字段表示携带的参数 path: '/login' &#125;) &#125; return response; &#125;, error =&gt; &#123; return Promise.reject(error.response.data) &#125;);export default axios;/** * fetch 请求方法 * @param url * @param params * @returns &#123;Promise&#125; */export function fetch(url, params = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.get(url, &#123; params: params &#125;) .then(response =&gt; &#123; resolve(response.data); &#125;) .catch(err =&gt; &#123; reject(err) &#125;) &#125;)&#125;/** * post 请求方法 * @param url * @param data * @returns &#123;Promise&#125; */export function post(url, data = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(url, data) .then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err); &#125;) &#125;)&#125;/** * patch 方法封装 * @param url * @param data * @returns &#123;Promise&#125; */export function patch(url, data = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.patch(url, data) .then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err); &#125;) &#125;)&#125;/** * put 方法封装 * @param url * @param data * @returns &#123;Promise&#125; */export function put(url, data = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.put(url, data) .then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err); &#125;) &#125;)&#125; 动态配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import axios from 'axios' //引用axiosimport &#123;Promise&#125; from 'es6-promise' //引入Promise// axios 配置和拦截器都不用了，这里我使用了一个动态配置数据请求地址，在App.vue中，代码在下面，这个也不是必须的。//^_^下面都设置一个默认的头部，使用的时候可以传入数据覆盖^_^,例如使用fetch(GET)方法时，没有请求数据，但是请求头有变化，则应写成 fetch("地址", &#123;&#125;, &#123;"这里写头部的内容"&#125;) 记住没数据用一个空对象占位置/** * fetch 请求方法 * @param url * @param params * @returns &#123;Promise&#125; */export function fetch(url, params = &#123;&#125;, headers = &#123; 'Content-Type': 'application/json', //设置跨域头部 "Authorization": 'JWT ' + sessionStorage.getItem("authToken")&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.get(url, &#123; params: params, headers: headers &#125;) .then(response =&gt; &#123; resolve(response.data); &#125;) .catch(err =&gt; &#123; reject(err.response) &#125;) &#125;)&#125;/** * post 请求方法 * @param url * @param data * @returns &#123;Promise&#125; */export function post(url, data = &#123;&#125;, config = &#123; "headers": &#123; 'Content-Type': 'application/json', //设置跨域头部 "Authorization": 'JWT ' + sessionStorage.getItem("authToken") &#125;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(url, data, config) .then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err.response); &#125;) &#125;)&#125;/** * patch 方法封装 * @param url * @param data * @returns &#123;Promise&#125; */export function patch(url, data = &#123;&#125;, config = &#123; "headers": &#123; 'Content-Type': 'application/json', //设置跨域头部 "Authorization": 'JWT ' + sessionStorage.getItem("authToken") &#125;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.patch(url, data, config) .then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err.response); &#125;) &#125;)&#125;/** * put 方法封装 * @param url * @param data * @returns &#123;Promise&#125; */export function put(url, data = &#123;&#125;, config = &#123; "headers": &#123; 'Content-Type': 'application/json', //设置跨域头部 "Authorization": 'JWT ' + sessionStorage.getItem("authToken") &#125;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.put(url, data, config) .then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err.response); &#125;) &#125;)&#125; 使用： 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id="app"&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from 'axios';let protocol = window.location.protocol; //协议let host = window.location.host; //主机let reg = /^localhost+/;if(reg.test(host)) &#123; //若本地项目调试使用 axios.defaults.baseURL = 'http://xx.xx.xx.xx:xxxx/api/';&#125; else &#123; //动态请求地址 axios.defaults.baseURL = protocol + "//" + host + "/api/";&#125;axios.defaults.timeout = 30000;export default &#123; name: 'app', axios //这里记得导出，若请求地址永久固定一个，则就按照`普通版`配置一个baserURL就可以了&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 总结在使用动态版时，为什么称为动态呢，是因为访问地址和请求地址是同一个地址可端口号，例如我通过http://www.xxxx.com(默认端口80)访问项目，那么我的baseURL会自动的变为http//:www.xxxx.com:80/api/，这么做的原因是当某一天项目迁移或者http改为https时，不用你再去更改请求地址，程序自动就完成了。 假如数据请求地址配置不正确，如果你配置了baseURL，那么你封装的函数在使用时仅需传入基于baseURL的请求地址，例如传入login/那么请求地址会自动变为http://www.xxxx.com:80/api/login/，若未配置，那么可以直接传入整个请求地址 在使用动态版时，由于没有使用拦截器，所以下面封装的函数在返回错误的时候需要写成err.response.data来获取返回的数据，但我写的是err.response，因为这样可以拿到(status)状态码等信息，若不需要判断返回的状态码，则改为err.response.data便可 参考 Axios.js上手和动态Axios配置 github-axios]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6核心内容]]></title>
    <url>%2F2018%2F07%2F10%2FES6%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[ES6简介ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。也就是说，ES6就是ES2015。 最常用的ES6特性let, const, class, extends, super, arrow functions, template string, destructuring, default, rest arguments let,const123456789var name = 'zach'while (true) &#123; var name = 'pyt' console.log(name) //pyt break&#125;console.log(name) //pyt 使用var两次输出都是pyt，这是因为ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景就是你现在看到的内层变量覆盖外层变量。而let则实际上为JavaScript新增了块级作用域。用它所声明的变量，只在let命令所在的代码块内有效。 123456789let name = 'pan'while (true) &#123; let name = 'zhou' console.log(name) //zhou break&#125;console.log(name) //pan 另外一个var带来的不合理场景就是用来计数的循环变量泄露为全局变量，看下面的例子： 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。 123const PI = Math.PIPI = 23 //Module build failed: SyntaxError: /es6/app.js: "PI" is read-only class, extends, superES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。 123456789101112131415161718192021class Animal &#123; constructor()&#123; this.type = 'animal' &#125; says(say)&#123; console.log(this.type + ' says ' + say) &#125;&#125;let animal = new Animal()animal.says('hello') //animal says helloclass Cat extends Animal &#123; constructor()&#123; super() this.type = 'cat' &#125;&#125;let cat = new Cat()cat.says('hello') //cat says hello 上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。 Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Cat类，该类通过extends关键字，继承了Animal类的所有属性和方法。 super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 arrow function这个恐怕是ES6最最常用的一个新特性了，用它来写function比原来的写法要简洁清晰很多: 12345678910function(i)&#123; return i + 1; &#125; //ES5(i) =&gt; i + 1 //ES6function(x, y) &#123; x++; y--; return x + y;&#125;(x, y) =&gt; &#123;x++; y--; return x+y&#125; 除了看上去更简洁以外，arrow function还有一项超级无敌的功能！长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。例如： 12345678910111213class Animal &#123; constructor()&#123; this.type = 'animal' &#125; says(say)&#123; setTimeout(function()&#123; console.log(this.type + ' says ' + say) &#125;, 1000) &#125;&#125; var animal = new Animal() animal.says('hi') //undefined says hi 运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象。所以为了让它能够正确的运行，传统的解决方法有两种： 第一种是将this传给self,再用self来指代this 123456says(say)&#123; var self = this; setTimeout(function()&#123; console.log(self.type + ' says ' + say) &#125;, 1000)&#125; 第二种方法是用bind(this),即 12345says(say)&#123; setTimeout(function()&#123; console.log(this.type + ' says ' + say) &#125;.bind(this), 1000)&#125; 但现在我们有了箭头函数，就不需要这么麻烦了： 123456789101112class Animal &#123; constructor()&#123; this.type = 'animal' &#125; says(say)&#123; setTimeout( () =&gt; &#123; console.log(this.type + ' says ' + say) &#125;, 1000) &#125;&#125; var animal = new Animal() animal.says('hi') //animal says hi 当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。 template string当我们要插入大段的html内容到文档中时，传统的写法非常麻烦，所以之前我们通常会引用一些模板工具库，比如mustache等等。以前的代码，我们要用一堆的’+’号来连接文本与变量：123456$("#result").append( "There are &lt;b&gt;" + basket.count + "&lt;/b&gt; " + "items in your basket, " + "&lt;em&gt;" + basket.onSale + "&lt;/em&gt; are on sale!"); now，使用ES6的新特性模板字符串12345$("#result").append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 用反引号（``）来标识起始，用${}来引用变量，而且所有的空格和缩进都会被保留在输出之中。 destructuringES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。例如： 1234let cat = 'ken'let dog = 'lili'let zoo = &#123;cat: cat, dog: dog&#125;console.log(zoo) //Object &#123;cat: "ken", dog: "lili"&#125; 12345678910//ES6let cat = 'ken'let dog = 'lili'let zoo = &#123;cat, dog&#125;console.log(zoo) //Object &#123;cat: "ken", dog: "lili"&#125;//反过来可以这么写：let dog = &#123;type: 'animal', many: 2&#125;let &#123; type, many&#125; = dogconsole.log(type, many) //animal 2 default, restdefault很简单，意思就是默认值。大家可以看下面的例子，调用animal()方法时忘了传参数，传统的做法就是加上这一句type = type || &#39;cat&#39; 来指定默认值。 12345function animal(type)&#123; type = type || 'cat' console.log(type)&#125;animal() 最后一个rest语法也很简单，直接看例子： 1234function animals(...types)&#123; console.log(types)&#125;animals('cat', 'dog', 'fish') //["cat", "dog", "fish"] 而如果不用ES6的话，我们则得使用ES5的arguments。 import export这两个家伙对应的就是es6自己的module功能。 我们之前写的Javascript一直都没有模块化的体系，无法将一个庞大的js工程拆分成一个个功能相对独立但相互依赖的小工程，再用一种简单的方法把这些小工程连接在一起。 这有可能导致两个问题： 1.一方面js代码变得很臃肿，难以维护 2.另一方面我们常常得很注意每个script标签在html中的位置，因为它们通常有依赖关系，顺序错了可能就会出bug 在es6之前为解决上面提到的问题，我们得利用第三方提供的一些方案，主要有两种CommonJS(服务器端)和AMD（浏览器端，如require.js）。 而现在我们有了es6的module功能，它实现非常简单，可以成为服务器和浏览器通用的模块解决方案。 ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。 首先我们回顾下require.js的写法。假设我们有两个js文件: index.js和content.js,现在我们想要在index.js中使用content.js返回的结果，我们要怎么做呢？ 首先定义：1234//content.jsdefine('content.js', function()&#123; return 'A cat';&#125;) 然后require：1234//index.jsrequire(['./content.js'], function(animal)&#123; console.log(animal); //A cat&#125;) 那CommonJS是怎么写的呢？12345//index.jsvar animal = require('./content.js')//content.jsmodule.exports = 'A cat' ES6的写法12345//index.jsimport animal from './content'//content.jsexport default 'A cat' ES6 module的其他高级用法1234567//content.jsexport default 'A cat' export function say()&#123; return 'Hello!'&#125; export const type = 'dog' 上面可以看出，export命令除了输出变量，还可以输出函数，甚至是类12345//index.jsimport &#123; say, type &#125; from './content' let says = say()console.log(`The $&#123;type&#125; says $&#123;says&#125;`) //The dog says Hello 这里输入的时候要注意：大括号里面的变量名，必须与被导入模块（content.js）对外接口的名称相同。 如果还希望输入content.js中输出的默认值(default), 可以写在大括号外面。123456//index.jsimport animal, &#123; say, type &#125; from './content' let says = say()console.log(`The $&#123;type&#125; says $&#123;says&#125; to $&#123;animal&#125;`) //The dog says Hello to A cat 修改变量名：此时我们不喜欢type这个变量名，因为它有可能重名，所以我们需要修改一下它的变量名。在es6中可以用as实现一键换名。123456//index.jsimport animal, &#123; say, type as animalType &#125; from './content' let says = say()console.log(`The $&#123;animalType&#125; says $&#123;says&#125; to $&#123;animal&#125;`) //The dog says Hello to A cat 模块的整体加载：除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。12345//index.jsimport animal, * as content from './content' let says = content.say()console.log(`The $&#123;content.type&#125; says $&#123;says&#125; to $&#123;animal&#125;`) //The dog says Hello to A cat 通常星号*结合as一起使用比较合适。 考虑下面的场景：上面的content.js一共输出了三个变量（default, say, type）,假如我们的实际项目当中只需要用到type这一个变量，其余两个我们暂时不需要。我们可以只输入一个变量：1import &#123; type &#125; from './content' 由于其他两个变量没有被使用，我们希望代码打包的时候也忽略它们，抛弃它们，这样在大项目中可以显著减少文件的体积。 参考文章 https://segmentfault.com/a/1190000004365693 https://segmentfault.com/a/1190000004368132]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack简单搭建]]></title>
    <url>%2F2018%2F07%2F02%2Fwebpack%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Webpack4 简单搭建webpack简介本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 四个核心概念： 入口(entry) 输出(output) loader 插件(plugins) webpack中文网：https://webpack.docschina.org npm简介npm 是JavaScript 世界的包管理工具，并且是Node.js 平台的默认包管理工具。通过npm 可以安装、共享、分发代码，管理项目依赖关系。 npm中文网：https://www.npmjs.com.cn npm装包时的区别 -D -S -g我们在使用npm install 安装模块或插件的时候，有两种命令把他们写入到 package.json 文件里面去，比如：1```--save 在 package.json 文件里面提现出来的区别就是，使用 –save-dev 安装的 插件，被写入到devDependencies 对象里面去，而使用 –save 安装的插件，责被写入到 dependencies 对象里面去。那 package.json 文件里面的 devDependencies 和 dependencies 对象有什么区别呢？devDependencies 里面的插件只用于开发环境，不用于生产环境，而 dependencies 是需要发布到生产环境的。12345678910npm i module_name -S =&gt; npm install module_name --save 写入到 dependencies 对象 ornpm i -S module_name npm i module_name -D ==&gt; npm install module_name --save-dev 写入到 devDependencies 对象 ornpm i -D module_name npm i module_name -g 全局安装 i 是install 的简写 备注：详细信息可以用 help install``` 查看123456## webpack4 基础配置### 安装webpack、webpack-cli、webpack-dev-server- NPM初始化```npm init 本地局部安装webpack、webpack-clii webpack webpack-cli -D```12安装成功后 “devDependencies”: {“webpack”: “^4.14.0”,“webpack-cli”: “^3.0.8”}12- 本地局部安装webpack-dev-server```npm i webpack-dev-server -D 12345&quot;devDependencies&quot;: &#123;&quot;webpack&quot;: &quot;^4.14.0&quot;,&quot;webpack-cli&quot;: &quot;^3.0.8&quot;,&quot;webpack-dev-server&quot;: &quot;^3.1.4&quot;&#125; 增加快速启动服务脚本12345&quot;scripts&quot;: &#123;&quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,&quot;dev&quot;: &quot;webpack-dev-server --open --config webpack.config.js&quot;,&quot;build&quot;: &quot;webpack --progress --hide-modules --config webpack.prod.config.js&quot;&#125;, 备注： IP和端口是可以配置的123&quot;scripts&quot;: &#123;&quot;dev&quot;: &quot;webpack-dev-server --host 172.172.172.1 --port 8888 --open --config webpack.config.js&quot;,&#125;, webpack和webpack-dev-server区别第一：webpack只是构建webpack-dev-server除了构建，还提供web服务第二：webpack.config.json的路径参数显然，entry都一样，因为都要知道需要构建的文件在哪里那么区别就在于 output了path和webpack一起，指明构建 之后 输出文件的位置，这是真实的物理地址 publickPath和webpack-dev-server一起，当执行webpack-dev-server时，第一步首先跟webpack一样，先构建输出，然后提供web访问，该输出文件是在内存中 默认情况下，不设置publicPath则输出文件默认在运行webpack-dev-server的目录，也就是根目录，，那么html中引用直接是src=”输出的文件”，，如果设置了publicPath那么html中引用也要相对改变 总的来说，webpack只是构建，而webpack-dev-server相当于webpack+apache（或者其它web服务器） 区别在于 使用webpack+apache（或者其它服务器），每次构建之后，首先1 根据path引用构建后的输出文件；2 每次修改都要重新运行webpack 使用webpack-dev-server，运行之后首先1 先构建，输出文件在内存中，引用构建后的输出文件根据publicPath（默认是根目录）；2 每次修改，自动刷新 webpack执行命令参数12345678webpack --config XXX.js //使用另一份配置文件（比如webpack.prod.config.js）来打包webpack --watch //监听变动并自动打包webpack --colors 配置打包输出颜色显示webpack -p//压缩混淆脚本，这个非常非常重要！webpack -d//生成map映射文件，告知哪些模块被最终打包到哪里了其中的 webpack --progress //显示进度条webpack --color //添加颜色webpack --hide-modules //隐藏来自文件夹的模块 配置文件添加webpack.config.js配置文件在webpack.config.js中进行入口和输出的配置123456789101112var path = require(&apos;path&apos;);var config = &#123; entry: &#123; main: &apos;./main&apos; &#125;, output: &#123; path: path.join(__dirname, &apos;./dist&apos;), publicPath: &apos;/dist/&apos;, filename: &apos;main.js&apos; &#125;&#125;;module.exports = config; 使用不同的加载器(Loaders)处理不同的模块 例如使用CSS样式：i css-loader -D```1```npm i style-loader -D 123456789101112131415var config = &#123; //... module: &#123; rules: [ &#123; test: /\.css$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125; ] &#125;&#125;;module.exports = config; 插件(Plugins)例如提取散落的CSS 安装extract-text-webpack-plugin插件1npm i extract-text-webpack-plugin -D 12345678910111213141516171819202122232425262728var path = require(&apos;path&apos;);var ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);var config = &#123; entry: &#123; main: &apos;./main&apos; &#125;, output: &#123; path: path.join(__dirname, &apos;./dist&apos;), publicPath: &apos;/dist/&apos;, filename: &apos;main.js&apos; &#125;, module: &#123; rules: [ &#123; test: /\.css$/, css: ExtractTextPlugin.extract(&#123; use: &apos;css-loader&apos;, fallback: &apos;style-loader&apos; &#125;) &#125; ] &#125;, plugins: [ new ExtractTextPlugin(&quot;main.css&quot;) ]&#125;;module.exports = config; 可能会遇到下面的错误1Error: Chunk.entrypoints: Use Chunks.groupsIterable and filter by instanceof Entrypoint instead 这个是由于版本的问题造成的，解决方法如下： npm install extract-text-webpack-plugin@next]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java生成PDF]]></title>
    <url>%2F2018%2F05%2F28%2Fjava%E7%94%9F%E6%88%90PDF%2F</url>
    <content type="text"><![CDATA[使用iText库创建PDF文件 iText是著名的开放项目，是用于生成PDF文档的一个java类库。通过iText不仅可以生成PDF或rtf的文档，而且可以将XML、Html文件转化为PDF文件。这里简单记录一下我对IText的使用。 项目依赖123456789101112131415161718//项目要使用iText，必须引入jar包。才能使用，maven依赖如下：&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.5.10&lt;/version&gt;&lt;/dependency&gt;//输出中文，还要引入下面itext-asian.jar包&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itext-asian&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt;&lt;/dependency&gt;//设置pdf文件密码，还要引入下面bcprov-jdk15on.jar包&lt;dependency&gt; &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt; &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt; &lt;version&gt;1.54&lt;/version&gt;&lt;/dependency&gt; iText常用的类 com.itextpdf.text.Document：这是iText库中最常用的类，它代表了一个pdf实例。如果你需要从零开始生成一个PDF文件，你需要使用这个Document类。首先创建（new）该实例，然后打开（open）它，并添加（add）内容，最后关闭（close）该实例，即可生成一个pdf文件。 com.itextpdf.text.Paragraph：表示一个缩进的文本段落，在段落中，你可以设置对齐方式，缩进，段落前后间隔等。 com.itextpdf.text.Chapter：表示PDF的一个章节，他通过一个Paragraph类型的标题和整形章数创建。 com.itextpdf.text.Font：这个类包含了所有规范好的字体，包括family of font，大小，样式和颜色，所有这些字体都被声明为静态常量。 com.itextpdf.text.List：表示一个列表； com.itextpdf.text.Anchor：表示一个锚，类似于HTML页面的链接。 com.itextpdf.text.pdf.PdfWriter：当这个PdfWriter被添加到PdfDocument后，所有添加到Document的内容将会写入到与文件或网络关联的输出流中。 com.itextpdf.text.pdf.PdfReader：用于读取PDF文件； 简单样例12345678910111213141516171819202122232425262728293031import java.io.FileNotFoundException;import java.io.FileOutputStream;import com.itextpdf.text.Document;import com.itextpdf.text.DocumentException;import com.itextpdf.text.Paragraph;import com.itextpdf.text.pdf.PdfWriter;public class TestPDFDemo1 &#123; public static void main(String[] args) throws FileNotFoundException, DocumentException &#123; // 1.新建document对象 Document document = new Document(); // 2.建立一个书写器(Writer)与document对象关联，通过书写器(Writer)可以将文档写入到磁盘中。 // 创建 PdfWriter 对象 第一个参数是对文档对象的引用，第二个参数是文件的实际名称，在该名称中还会给出其输出路径。 PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream("C:/Users/Ac__LBJ/Desktop/test.pdf")); // 3.打开文档 document.open(); // 4.添加一个内容段落 document.add(new Paragraph("Hello World!")); // 5.关闭文档 document.close(); &#125;&#125; 生成表格(含图片)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.party.www.util.pyt;import com.itextpdf.text.*;import com.itextpdf.text.pdf.BaseFont;import com.itextpdf.text.pdf.PdfPCell;import com.itextpdf.text.pdf.PdfPTable;import com.itextpdf.text.pdf.PdfWriter;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.net.URL;public class pytTest &#123; public static void main(String[] args) throws DocumentException, IOException &#123; //创建文件 Document document = new Document(); //建立一个书写器 PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream("C:\\Users\\Ac__LBJ\\Desktop\\b.pdf")); //打开文件 document.open(); //创建一个简体中文的基本字体、UniGB-UCS2-H为简体中文 BaseFont base = BaseFont.createFont("STSong-Light", "UniGB-UCS2-H",BaseFont.EMBEDDED); Font fontChinese = new Font(base, 12, Font.NORMAL); PdfPTable table = new PdfPTable(1); // 3 columns. table.setWidthPercentage(100); // Width 100% table.setSpacingBefore(10f); // Space before table table.setSpacingAfter(0); // Space after table PdfPCell cell1 = new PdfPCell(new Paragraph("标题：",fontChinese)); cell1.setBorder(0);//隐藏边框（设置边框宽度为0） PdfPCell cell11 = new PdfPCell(new Paragraph("西南科技大学党委书记祝贺骑士获得总冠军",fontChinese)); cell11.setBorder(0); PdfPCell cell2 = new PdfPCell(new Paragraph("内容：",fontChinese)); cell2.setBorder(0); PdfPCell cell22 = new PdfPCell(new Paragraph("西南科技大学党委书记祝贺骑士获得总冠军西南科技大学党委书记祝贺骑士获得总冠军",fontChinese)); cell22.setBorder(0); table.addCell(cell1); table.addCell(cell11); table.addCell(cell2); table.addCell(cell22); document.add(table); PdfPTable imgTable = new PdfPTable(3); // 3 columns. imgTable.setWidthPercentage(100); // Width 100% imgTable.setSpacingBefore(10f); // Space before table imgTable.setSpacingAfter(0); // Space after table imgTable.getDefaultCell().setBorder(0); for (int i =0 ;i&lt;6 ;i++)&#123; Image image = Image.getInstance("C:\\Users\\Ac__LBJ\\Desktop\\aaa.png"); imgTable.addCell(image); &#125; document.add(imgTable); //关闭文档 document.close(); //关闭书写器 writer.close(); &#125;&#125; 参考博客 https://www.cnblogs.com/chenpi/p/5534595.html#_label6 http://www.cnblogs.com/h--d/p/6150320.html http://rensanning.iteye.com/blog/1538689]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas简单学习]]></title>
    <url>%2F2018%2F05%2F27%2Fcanvas%E7%AE%80%E5%8D%95%E6%A0%B7%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Canvas基础简介12&lt;canvas&gt;是HTML5新增的元素，可用于通过使用JavaScript中的脚本来绘制图形。例如，它可以用于绘制图形，制作照片，创建动画，甚至可以进行实时视频处理或渲染。 1&lt;canvas id="tutorial" width="150" height="150"&gt;&lt;/canvas&gt; 12&lt;canvas&gt;看起来和&lt;img&gt;元素很相像，唯一的不同就是它并没有 src 和 alt 属性。实际上，&lt;canvas&gt; 标签只有两个属性—— width 和 height。 简单例子123456789101112131415161718192021&lt;html&gt; &lt;head&gt; &lt;script type="application/javascript"&gt; function draw() &#123; var canvas = document.getElementById("canvas"); if (canvas.getContext) &#123; var ctx = canvas.getContext("2d"); ctx.fillStyle = "rgb(200,0,0)"; ctx.fillRect (10, 10, 55, 50); ctx.fillStyle = "rgba(0, 0, 200, 0.5)"; ctx.fillRect (30, 30, 55, 50); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload="draw();"&gt; &lt;canvas id="canvas" width="150" height="150"&gt;&lt;/canvas&gt; &lt;/body&gt;&lt;/html&gt; 像素操作1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Canvas学习&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="600" height="600" style="border:1px solid #d3d3d3;"&gt; 您的浏览器不支持 HTML5 canvas 标签。 &lt;/canvas&gt; &lt;script&gt; var c = document.getElementById("myCanvas"); var ctx = c.getContext("2d"); var imgData = ctx.createImageData(512, 512); for (var i = 0; i &lt; imgData.data.length; i += 4) &#123; imgData.data[i + 0] = 255; imgData.data[i + 1] = 0; imgData.data[i + 2] = 0; imgData.data[i + 3] = 255; &#125; // 将rgba数组一一赋值给imgData数组，注意：不能直接等，因为二者数组类型不一致 // for (var i = 0; i &lt; imgData.data.length; i++) &#123; // imgData.data[i] = myData[i]; // &#125; ctx.putImageData(imgData, 0, 0); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考学习 https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 文件上传]]></title>
    <url>%2F2017%2F12%2F27%2Ffileupload%2F</url>
    <content type="text"><![CDATA[Spring 文件上传 文件上传工具类 FileUploadUtil 1234567891011121314151617181920212223242526272829303132333435363738/** * 上传文件的公共方法 * @param uploadDir 上传文件目录 * @param file 上传对象 * @return 文件上传后的结果 * key = successFlag (boolean)表示文件是否上传成功 * key = fileName (String)表示文件的文件名 */public static Map&lt;String,Object&gt; executeUpload(String uploadDir, MultipartFile file)&#123; Map&lt;String,Object&gt; resultMap = new HashMap&lt;&gt;(); try &#123; //文件后缀名 String suffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(".")); //上传文件名 String filename = UUID.randomUUID() + suffix; //如果目录不存在，自动创建文件夹 File dir = new File(uploadDir); if(!dir.exists()) &#123; dir.mkdir(); &#125; //服务器端保存的文件对象 File serverFile = new File(uploadDir + filename); //将上传的文件写入到服务器端文件内 file.transferTo(serverFile); //打印文件存储信息 logger.info("文件上传成功，存储位置：&#123;&#125;&#123;&#125;",uploadDir,filename); //封装返回信息（是否成功标志、随机生成的文件名） resultMap.put("successFlag",true); resultMap.put("fileName",filename); &#125; catch (IOException e) &#123; e.printStackTrace(); logger.error("文件上传失败！"); resultMap.put("successFlag",false); &#125; return resultMap;&#125; 单文件上传方法1234567891011121314151617181920212223242526272829/** * 上传文件方法 * @param file 前台上传的文件对象 * @return */@RequestMapping(value = "/upload",method = RequestMethod.POST)@ResponseBodypublic Object upload(HttpServletRequest request, MultipartFile file)&#123; Map&lt;String,Object&gt; resultMap = new HashMap&lt;&gt;(); try &#123; //上传目录地址 String uploadDir = request.getSession().getServletContext().getRealPath("/") +"upload/"; //调用上传方法 Map&lt;String,Object&gt; ans = FileUploadUtil.executeUpload(uploadDir,file); if (ans.get("successFlag").equals(true))&#123; resultMap.put("name",ans.get("fileName")); &#125; else &#123; resultMap.put("msg","false"); &#125; &#125;catch (Exception e) &#123; //打印错误堆栈信息 e.printStackTrace(); resultMap.put("msg","false"); &#125; return resultMap;&#125; 多文件上传方法1234567891011121314151617181920212223242526272829303132333435363738/** * 上传多个文件 * @param request 请求对象 * @param file 上传文件集合 * @return */@RequestMapping(value = "/uploads",method = RequestMethod.POST)@ResponseBodypublic Object uploads(HttpServletRequest request,MultipartFile[] file)&#123; Map&lt;String,Object&gt; resultMap = new HashMap&lt;&gt;(); StringBuffer fileName = new StringBuffer(); try &#123; //上传目录地址 String uploadDir = request.getSession().getServletContext().getRealPath("/") +"upload/"; //遍历文件数组执行上传 for (int i =0;i&lt;file.length;i++) &#123; if(file[i] != null) &#123; //调用上传方法 Map&lt;String,Object&gt; ans = FileUploadUtil.executeUpload(uploadDir, file[i]); if (ans.get("successFlag").equals(true))&#123; if (i == file.length - 1) &#123; fileName.append(ans.get("fileName")); &#125; else &#123; fileName.append(ans.get("fileName") + ","); &#125; &#125; &#125; &#125; resultMap.put("name",fileName); &#125;catch (Exception e) &#123; //打印错误堆栈信息 e.printStackTrace(); resultMap.put("msg","false"); &#125; return resultMap;&#125; 文件下载 一般情况下，只需要将文件路径返回给前端，通过点击文件路径，就能实现文件下载。 12345678910111213141516171819202122232425262728293031323334353637383940414243@RequestMapping(value = "/download")@ResponseBodypublic void download(HttpServletRequest request, HttpServletResponse response)&#123; //System.out.println(name); String name = "16cd89a7-1160-4ec4-8ef5-4ad6f2e96002.doc"; try&#123; String uploadDir = request.getSession().getServletContext().getRealPath("/") +"upload/"; File file = new File(uploadDir + name); //判断文件是否存在 if(!file.exists()) &#123; return; &#125; //判断文件类型 String mimeType = URLConnection.guessContentTypeFromName(file.getName()); if(mimeType == null) &#123; mimeType = "application/octet-stream"; &#125; response.setContentType(mimeType); //设置文件响应大小 response.setContentLengthLong(file.length()); //文件名编码，解决乱码问题 String fileName = file.getName(); String encodedFileName = null; String userAgentString = request.getHeader("User-Agent"); String browser = UserAgent.parseUserAgentString(userAgentString).getBrowser().getGroup().getName(); if(browser.equals("Chrome") || browser.equals("Internet Exploer") || browser.equals("Safari")) &#123; encodedFileName = URLEncoder.encode(fileName,"utf-8").replaceAll("\\+", "%20"); &#125; else &#123; encodedFileName = MimeUtility.encodeWord(fileName); &#125; //设置Content-Disposition响应头，一方面可以指定下载的文件名，另一方面可以引导浏览器弹出文件下载窗口 response.setHeader("Content-Disposition", "attachment;fileName=\"" + encodedFileName + "\""); //文件下载 InputStream in = new BufferedInputStream(new FileInputStream(file)); FileCopyUtils.copy(in, response.getOutputStream()); &#125;catch (IOException e)&#123; &#125;&#125; 文件拷贝上的性能差异分析及参考文章 通过零拷贝实现有效数据传输 Java IO和Java NIO在文件拷贝上的性能差异分析 Java 复制大文件方式（nio2 FileChannel 拷贝文件能力测试） SpringMVC上传文件的三种方式 Spring MVC中优雅地进行文件下载以及下载文件名乱码的一些探讨 Springboot文件下载]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring 邮件服务]]></title>
    <url>%2F2017%2F12%2F27%2Fjavamail%2F</url>
    <content type="text"><![CDATA[对JavaMailSender用法做个简单的小结在Spring Boot的工程中的pom.xml中引入spring-boot-starter-mail依赖：12345&lt;!-- 邮件依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 12345&lt;!-- 模板引擎 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 在配置文件中添加相应的属性 在application.properties中 123456spring.mail.host=smtp.qq.comspring.mail.username=邮箱账号spring.mail.password=授权码（不是邮箱密码）spring.mail.properties.mail.smtp.auth=truespring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=true 在application.yml中 1234567891011121314mail: host: smtp.qq.com（QQ邮箱为例） username: 邮箱账号 password: 授权码（不是邮箱密码） default-encoding: UTF-8 fromMail: addr: 发送方邮箱 properties: mail: smtp: auth: true starttls: enable: true required: true 简单使用 由于Spring Boot的starter模块提供了自动化配置，所以在引入了spring-boot-starter-mail依赖之后，会根据配置文件中的内容去创建JavaMailSender实例，因此我们可以直接在需要使用的地方直接@Autowired来引入邮件发送对象。我们通过使用SimpleMailMessage实现了简单的邮件发送，也可以使用MimeMessage来设置复杂一些的邮件内容。 编写MailService和MailServiceImpl 编写MailService接口 123456789public interface MailService &#123; public void sendSimpleMail(String to, String subject, String content); public void sendHtmlMail(String to, String subject, String content); public void sendAttachmentsMail(String to, String subject, String content, String filePath); public void sendInlineResourceMail(String to, String subject, String content, String rscPath, String rscId);&#125; 编写MailServiceImpl实现类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118@Servicepublic class MailServiceImpl implements MailService&#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private JavaMailSender mailSender;// @Value("$&#123;mail.fromMail.addr&#125;")// private String from; private String from = "1006936991@qq.com"; /** * 发送文本邮件 * @param to 目标邮箱 * @param subject 邮件主题 * @param content 邮件内容 */ @Override public void sendSimpleMail(String to, String subject, String content) &#123; SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(from); message.setTo(to); message.setSubject(subject); message.setText(content); try &#123; mailSender.send(message); logger.info("简单邮件已经发送。"); &#125; catch (Exception e) &#123; logger.error("发送简单邮件时发生异常！", e); &#125; &#125; /** * 发送html邮件 * @param to * @param subject * @param content */ @Override public void sendHtmlMail(String to, String subject, String content) &#123; MimeMessage message = mailSender.createMimeMessage(); try &#123; //true表示需要创建一个multipart message MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); mailSender.send(message); logger.info("html邮件发送成功"); &#125; catch (MessagingException e) &#123; logger.error("发送html邮件时发生异常！", e); &#125; &#125; /** * 发送带附件的邮件 * @param to * @param subject * @param content * @param filePath */ public void sendAttachmentsMail(String to, String subject, String content, String filePath)&#123; MimeMessage message = mailSender.createMimeMessage(); try &#123; MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); FileSystemResource file = new FileSystemResource(new File(filePath)); String fileName = filePath.substring(filePath.lastIndexOf(File.separator)); helper.addAttachment(fileName, file); //helper.addAttachment("test"+fileName, file); mailSender.send(message); logger.info("带附件的邮件已经发送。"); &#125; catch (MessagingException e) &#123; logger.error("发送带附件的邮件时发生异常！", e); &#125; &#125; /** * 发送正文中有静态资源（图片）的邮件 * @param to * @param subject * @param content * @param rscPath * @param rscId */ public void sendInlineResourceMail(String to, String subject, String content, String rscPath, String rscId) &#123; MimeMessage message = mailSender.createMimeMessage(); try &#123; MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); FileSystemResource res = new FileSystemResource(new File(rscPath)); helper.addInline(rscId, res); mailSender.send(message); logger.info("嵌入静态资源的邮件已经发送。"); &#125; catch (MessagingException e) &#123; logger.error("发送嵌入静态资源的邮件时发生异常！", e); &#125; &#125;&#125; 测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.smile.service;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import org.thymeleaf.TemplateEngine;import org.thymeleaf.context.Context;/** * Created by pyt on 2017/12/26/0026. */@RunWith(SpringRunner.class)@SpringBootTestpublic class MailServiceTest &#123; @Autowired private MailService mailService; @Autowired private TemplateEngine templateEngine; @Test public void testSimpleMail() throws Exception &#123; mailService.sendSimpleMail("307080368@qq.com","test simple mail"," pyt,this is simple mail"); &#125; @Test public void testHtmlMail() throws Exception &#123; String content="&lt;html&gt;\n" + "&lt;body&gt;\n" + " &lt;h3&gt;hello world ! 这是一封html邮件!&lt;/h3&gt;\n" + "&lt;/body&gt;\n" + "&lt;/html&gt;"; mailService.sendHtmlMail("307080368@qq.com","test simple mail",content); &#125; @Test public void sendAttachmentsMail() &#123; String filePath="F:\\javaPhotoTest\\LearnDo\\1513167730446da70.doc"; mailService.sendAttachmentsMail("307080368@qq.com", "主题：带附件的邮件", "涛哥有附件，请查收！", filePath); &#125; @Test public void sendInlineResourceMail() &#123; String rscId = "myImg"; String content="&lt;html&gt;&lt;body&gt;这是有图片的邮件：&lt;img src=\'cid:" + rscId + "\' &gt;&lt;/body&gt;&lt;/html&gt;"; String imgPath = "F:\\javaPhotoTest\\InnerParty\\1513761305358f62a.jpg"; mailService.sendInlineResourceMail("307080368@qq.com", "主题：这是有图片的邮件", content, imgPath, rscId); &#125; @Test public void sendTemplateMail() &#123; //创建邮件正文 Context context = new Context(); context.setVariable("id", "1"); String emailContent = templateEngine.process("emailTemplate", context); mailService.sendHtmlMail("307080368@qq.com","主题：这是模板邮件",emailContent); &#125;&#125; 备注: 12345html语言可以带上图片链接&lt;img src=&quot;c:/test.jpg&quot;&gt; &lt;/img&gt;那么我们在发送邮件的时候就需要对这些链接的图片做特殊处理,否则在对方接收到邮件的时候会看不到图片。我们特殊处理的方法就是把它们当成附件发送，但不显示在附件里。要做到这些就首先需要对输入的content进行解析，找到所带图片的路径。然后把content中&lt;img src=&quot;c:/test.jpg&quot;&gt; &lt;/img&gt; 这段代码变成&lt;img src=&quot;cid:IMG&quot;&gt; &lt;/img&gt; Spring Boot中开发Web应用时，模板默认位于resources/templates/目录下，可以添加邮件模板 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="zh" xmlns:th="http://www.thymeleaf.org"&gt; &lt;head&gt; &lt;meta charset="UTF-8"/&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 您好,这是验证邮件,请点击下面的链接完成验证,&lt;br/&gt; &lt;!--&lt;a href="#" th:href="@&#123; http://www.panyutao.top/&#123;id&#125;(id=$&#123;id&#125;) &#125;"&gt;查看博客&lt;/a&gt;--&gt; &lt;a href="#" th:href="@&#123; http://www.panyutao.top &#125;"&gt;查看博客&lt;/a&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot日志管理]]></title>
    <url>%2F2017%2F12%2F25%2Flogback%2F</url>
    <content type="text"><![CDATA[简单学习 SLF4J+LogbackSLF4J简介 slf4j的全称是Simple Loging Facade For Java，即它仅仅是一个为Java程序提供日志输出的统一接口，并不是一个具体的日志实现方案，就比如JDBC一样，只是一种规则而已。所以单独的slf4j是不能工作的，必须搭配其他具体的日志实现方案。slf4j只是一种接口，它本身并不关心你底层使用的是什么日志实现方案，所以它支持各种日志实现方案。简单的说，只要我们在类库中使用slf4j打日志，那么底层使用什么日志实现方案是使用者决定的，怎么决定？依靠配置文件和jar库。 SLF4J优势使用SLF4J的而不是直接使用 Log4j, commons logging, logback 或者 java.util.logging 1.在你的开源或内部类库中使用SLF4J会使得它独立于任何一个特定的日志实现，这意味着不需要管理多个日志配置或者多个日志类库，你的客户端会很感激这点。2.SLF4J提供了基于占位符的日志方法，这通过去除检查isDebugEnabled(), isInfoEnabled()等等，提高了代码可读性。3.通过使用SLF4J的日志方法，你可以延迟构建日志信息（Srting）的开销，直到你真正需要，这对于内存和CPU都是高效的。4.作为附注，更少的暂时的字符串意味着垃圾回收器（Garbage Collector）需要做更好的工作，这意味着你的应用程序有为更好的吞吐量和性能。 SLF4J+Logback配置pom.xml 配置123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; 新建 logback.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒当scan为true时，此属性生效。默认的时间间隔为1分钟。debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。--&gt;&lt;configuration scan="false" scanPeriod="60 seconds" debug="false"&gt; &lt;!-- 定义日志的根目录 --&gt; &lt;property name="LOG_HOME" value="F:\\javaPhotoTest\\log" /&gt; &lt;!-- 定义日志文件名称 --&gt; &lt;property name="appName" value="pan"&gt;&lt;/property&gt; &lt;!-- ch.qos.logback.core.ConsoleAppender 表示控制台输出 --&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 日志输出格式：%d表示日期时间，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息，%n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt; &lt;appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 指定日志文件的名称 --&gt; &lt;file&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;.log&lt;/file&gt; &lt;!-- 当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名 TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 滚动时产生的文件的存放位置及文件名称 %d&#123;yyyy-MM-dd&#125;：按天进行日志滚动 %i：当文件大小超过maxFileSize时，按照i进行文件滚动 --&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log&lt;/fileNamePattern&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每天滚动， 且maxHistory是365，则只保存最近365天的文件，删除之前的旧文件。注意，删除旧文件是， 那些为了归档而创建的目录也会被删除。 --&gt; &lt;MaxHistory&gt;365&lt;/MaxHistory&gt; &lt;!-- 当日志文件超过maxFileSize指定的大小是，根据上面提到的%i进行日志文件滚动 注意此处配置SizeBasedTriggeringPolicy是无法实现按文件大小进行滚动的，必须配置timeBasedFileNamingAndTriggeringPolicy --&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;!-- 日志输出格式：%d表示日期时间，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息，%n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [ %thread ] - [ %-5level ] [ %logger&#123;50&#125; : %line ] - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- logger主要用于存放日志对象，也可以定义日志类型、级别 name：表示匹配的logger类型前缀，也就是包的前半部分 level：要记录的日志级别，包括 TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR additivity：作用在于children-logger是否使用 rootLogger配置的appender进行输出，false：表示只用当前logger的appender-ref，true：表示当前logger的appender-ref和rootLogger的appender-ref都有效 --&gt; &lt;!-- hibernate logger --&gt; &lt;!--&lt;logger name="org.hibernate" level="error" /&gt;--&gt; &lt;!-- Spring framework logger --&gt; &lt;logger name="org.springframework" level="error" additivity="false"&gt;&lt;/logger&gt; &lt;logger name="com.smile.dao" level="trace"&gt; &lt;appender-ref ref="file" /&gt; &lt;/logger&gt; &lt;!-- root与logger是父子关系，没有特别定义则默认为root，任何一个类只会和一个logger对应， 要么是定义的logger，要么是root，判断的关键在于找到这个logger，然后判断这个logger的appender和level。 --&gt; &lt;root level="info"&gt; &lt;appender-ref ref="console" /&gt; &lt;appender-ref ref="file" /&gt; &lt;/root&gt;&lt;/configuration&gt; 备注关于&lt;Encoding&gt;UTF-8&lt;/Encoding&gt; 1.设置Encoding。在appender中增加一行UTF-8，但是在启动中报错，说是不能识别Encoding元素。有人说Encoding在0.9.22以后版本中已经不能用了。2.设置charset, 在encoder 中增加一行 UTF-8，重新启动系统，日志中中文显示正常了。 附加Why do we declare Loggers static final?为什么要将日志记录定义为static以及final？ private - so that no other class can hijack your logger static - so there is only one logger instance per class, also avoiding attempts to serialize loggers final - no need to change the logger over the lifetime of the class]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 拦截器]]></title>
    <url>%2F2017%2F12%2F25%2Finterceptor%2F</url>
    <content type="text"><![CDATA[概述 Web开发中，我们除了使用 Filter 来过滤web请求外，还可以使用Spring提供的HandlerInterceptor（拦截器）。HandlerInterceptor 的功能跟过滤器类似，但是提供更精细的的控制能力：在request被响应之前、request被响应之后、视图渲染之前以及request全部结束之后。我们不能通过拦截器修改request内容，但是可以通过抛出异常（或者返回false）来暂停request的执行。 实现自定义拦截器三步走： 1.创建我们自己的拦截器类并实现 HandlerInterceptor 接口。 2.创建一个Java类继承WebMvcConfigurerAdapter，并重写 addInterceptors 方法。 3.实例化我们自定义的拦截器，然后将对像手动添加到拦截器链中（在addInterceptors方法中添加）。 样例登录状态拦截器12345678910111213141516171819202122232425262728293031323334public class SessionInterceptor implements HandlerInterceptor&#123; //在请求处理之前进行调用（Controller方法调用之前） @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object o) throws Exception &#123; System.out.println(request.getRequestURI()); //登录不做拦截 if(request.getRequestURI().equals("/user/login") || request.getRequestURI().equals("/user/login_view")) &#123; return true; &#125; //验证session是否存在 Object obj = request.getSession().getAttribute("_session_user"); if(obj == null) &#123; response.sendRedirect("/user/login_view"); return false; &#125; return true; &#125; //请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后） @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; &#125; //在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行（主要是用于进行资源清理工作） @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; &#125;&#125; 12345678@Configurationpublic class MyInterceptorConfig extends WebMvcConfigurerAdapter&#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new SessionInterceptor()).addPathPatterns("/**"); &#125;&#125; 处理时间拦截器123456789101112131415161718192021222324public class ChanelInterceptor implements HandlerInterceptor &#123; private static Logger logger = LoggerFactory.getLogger(ChanelInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object o) throws Exception &#123; logger.info("============================拦截器启动=============================="); request.setAttribute("starttime",System.currentTimeMillis()); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object o, ModelAndView modelAndView) throws Exception &#123; logger.info("===========================执行处理完毕============================="); long starttime = (long) request.getAttribute("starttime"); request.removeAttribute("starttime"); long endtime = System.currentTimeMillis(); logger.info("============请求地址："+request.getRequestURI()+"：处理时间：&#123;&#125;",(endtime-starttime)+"ms"); &#125; @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; logger.info("============================拦截器关闭=============================="); &#125;&#125; 1234567@Configurationpublic class MyInterceptorConfig extends WebMvcConfigurerAdapter&#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new ChanelInterceptor()).addPathPatterns("/**"); &#125;&#125;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis-generator]]></title>
    <url>%2F2017%2F12%2F25%2Fmappergenerator%2F</url>
    <content type="text"><![CDATA[Intellij IDEA 使用MyBatis-generator 自动生成MyBatis代码 步骤1在maven项目的pom.xml 添加mybatis-generator-maven-plugin 插件，如图： 123456789&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt;&lt;/plugin&gt; 步骤2 在maven项目下的src/main/resources 目录下建立名为 generatorConfig.xml的配置文件，作为mybatis-generator-maven-plugin 插件的执行目标 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- 数据库驱动包位置 --&gt; &lt;classPathEntry location="D:\mysql-5.7.19-winx64\mysql-connector-java-5.1.35.jar" /&gt; &lt;context id="MysqlTables" targetRuntime="MyBatis3"&gt; &lt;!--是否去除自动生成的注释 是：true 否：false--&gt; &lt;commentGenerator&gt; &lt;property name="suppressAllComments" value="true" /&gt; &lt;/commentGenerator&gt; &lt;!-- 数据库驱动类、链接URL、用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://120.79.6.242:3306/mytest?characterEncoding=utf8" userId="root" password="Swust306"&gt; &lt;!--&lt;jdbcConnection driverClass="oracle.jdbc.driver.OracleDriver" connectionURL="jdbc:oracle:thin:@localhost:1521:orcl" userId="msa" password="msa"&gt;--&gt; &lt;/jdbcConnection&gt; &lt;!--非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成模型的包名和位置 --&gt; &lt;javaModelGenerator targetPackage="com.smile.domain" targetProject="src\main\java"&gt; &lt;!--是否让schema作为包的后缀--&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;!--从数据库返回的值被清理前后的空格--&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成的映射文件包名和位置 --&gt; &lt;sqlMapGenerator targetPackage="com.smile.dao" targetProject="src\main\java"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.smile.dao" targetProject="src\main\java"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成那些表(更改tableName和domainObjectName就可以) --&gt; &lt;table schema="" tableName="article_info" domainObjectName="ArticleInfo"/&gt; &lt;!--&lt;table tableName="user_info" domainObjectName="UserInfo" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false" /&gt;--&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 步骤3 在Intellij IDEA添加一个“Run运行”选项，使用maven运行mybatis-generator-maven-plugin插件，如图：]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JXL操作Excel模板]]></title>
    <url>%2F2017%2F12%2F24%2Fjxl20171223%2F</url>
    <content type="text"><![CDATA[JXL操作Excel简单总结一下使用JXL来对Excel模板进行添加数据 最近遇到个需要，要对表头较为复杂的Excel进行数据的填充，考虑到表头的复杂性，没有选择一步步去合并单元格等操作来生成表头，故采用直接复制模板，然后对相应单元格进行操作，以此文章贴出代码来对其进行简单总结。 基础参考12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import com.excel.jxl.model.User;import jxl.Workbook;import jxl.read.biff.BiffException;import jxl.write.Boolean;import jxl.write.*;import jxl.write.Number;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.math.BigDecimal;import java.text.SimpleDateFormat;import java.util.Date;/** * Created by pyt on 2017/12/24/0022. */public class JxlReadExport &#123; private static final int MAX_ROWS = 100; public static void main(String[] args) throws IOException, BiffException &#123; // 表格要导出的目录 String outPath = "C:\\Users\\susq\\Desktop\\sheet.xls"; FileOutputStream is = new FileOutputStream(outPath); // 模板文件路径 String templePath = "C:\\Users\\susq\\Desktop\\模板.xls"; // 读取模板文件 Workbook wb = Workbook.getWorkbook(new File(templePath)); // 根据模板文件创建可写的文件，注意这里是createWorkbook(),创建而不是获取 WritableWorkbook wwb = Workbook.createWorkbook(is, wb); // 注意这里是getSheet(), 通过索引，获取模板文件中的sheet页第一页 WritableSheet sheet = wwb.getSheet(0); for(int i=1; i&lt;=MAX_ROWS; i++) &#123; // 从第二行开始插入，第一行表头 User user = new User((long) i, "张三", "14", true, new Date(), new BigDecimal("111112345.6789")); // 第一个参数指定单元格的列数、第二个参数指定单元格的行数，第三个指定写的字符串内容 // 填充数字， import jxl.write.Number; Number label1 = new Number(0, i, user.getId()); // 填充文本 Label label2 = new Label(1, i, user.getName()); Label label3 = new Label(2, i, user.getAge()); // 填充布尔值， import jxl.write.Boolean; Boolean label4 = new Boolean(3, i, user.getSex()); // 填充日期 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); String date = sdf.format(user.getCreateTime()); Label label5 = new Label(4, i, date); // 填充格式化的数字, 保留6位小数，不足六位的时候有几位保留几位。非小数部分用千位符隔开 jxl.write.NumberFormat nf = new jxl.write.NumberFormat("###,###,###.######"); jxl.write.WritableCellFormat wcf = new jxl.write.WritableCellFormat(nf); jxl.write.Number label6 = new jxl.write.Number(5, i, user.getSalary().doubleValue(), wcf); try &#123; sheet.addCell(label1); sheet.addCell(label2); sheet.addCell(label3); sheet.addCell(label4); sheet.addCell(label5); sheet.addCell(label6); &#125; catch (WriteException e) &#123; e.printStackTrace(); &#125; &#125; try &#123; wwb.write(); wwb.close(); is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (WriteException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 根据模板，生成对应的Excel，并填充数据(文本)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import jxl.CellView;import jxl.Workbook;import jxl.WorkbookSettings;import jxl.format.ScriptStyle;import jxl.format.UnderlineStyle;import jxl.read.biff.BiffException;import jxl.write.Boolean;import jxl.write.*;import jxl.write.Number;import jxl.write.biff.RowsExceededException;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.math.BigDecimal;import java.text.SimpleDateFormat;import java.util.Date;public class Test &#123; private static final int MAX_ROWS = 7; public static void main(String[] args) throws IOException, BiffException &#123; // TODO Auto-generated method stub // 表格要导出的目录 String outPath = "C:\\Users\\swust306xu\\Desktop\\sheet.xls"; FileOutputStream is = new FileOutputStream(outPath); // 模板文件路径 String templePath = "C:\\Users\\swust306xu\\Desktop\\业务发展指标.xls"; // 读取模板文件 Workbook wb = Workbook.getWorkbook(new File(templePath)); WorkbookSettings wbSettings = new WorkbookSettings (); wbSettings.setWriteAccess(null); // 根据模板文件创建可写的文件，注意这里是createWorkbook(),创建而不是获取 WritableWorkbook wwb = Workbook.createWorkbook(is, wb , wbSettings); // 注意这里是getSheet(), 通过索引，获取模板文件中的sheet页第一页 WritableSheet sheet = wwb.getSheet(0); WritableFont titleWf = new WritableFont(WritableFont.createFont("宋体"),// 字体 12,//WritableFont.DEFAULT_POINT_SIZE, // 字号 WritableFont.NO_BOLD, // 粗体 false, // 斜体 UnderlineStyle.NO_UNDERLINE, // 下划线 Colour.BLACK, // 字体颜色 ScriptStyle.NORMAL_SCRIPT); WritableCellFormat cFormat = new WritableCellFormat(titleWf); try &#123; cFormat.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,jxl.format.Colour.BLACK); &#125; catch (WriteException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; CellView cellView = new CellView(); cellView.setAutosize(true); //设置自动大小 Label lab = null; for(int i=5; i&lt;=MAX_ROWS; i++) &#123; // 从第二行开始插入，第一行表头 for(int j=0;j&lt;22;j++) &#123; sheet.setColumnView(i, cellView);//根据内容自动设置列宽 lab = new Label(j,i,"测试方法",cFormat); //Label(col,row,str); try &#123; sheet.addCell(lab); &#125; catch (RowsExceededException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (WriteException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; try &#123; wwb.write(); wwb.close(); is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (WriteException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>jxl</category>
      </categories>
      <tags>
        <tag>jxl</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令]]></title>
    <url>%2F2017%2F12%2F11%2Fhexocommon%2F</url>
    <content type="text"><![CDATA[Hexo命令总结常用命令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 复合命令12hexo deploy -g #生成加部署hexo server -g #生成加预览 命令简写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 部署步骤每次部署都可以按照下面的步骤，或者用上面的复合命令123hexo cleanhexo generatehexo deploy 本地测试12hexo g #生成hexo s #启动本地服务，进行文章预览调试 浏览器输入 http://localhost:4000 ，查看搭建效果。此后的每次变更_config.yml 文件或者新建文件都可以先用此命令调试，尤其是当你想调试新添加的主题时。可以用一条简化的命令 1hexo s -g 文章头部格式12345678---title: hexocommondate: 2017-12-11 21:23:17tags: - hexocategories: - hexo--- 基本配置参考文章：http://www.shenzekun.cn/hexo的next主题个性化配置教程.html]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post和Get的区别]]></title>
    <url>%2F2017%2F12%2F11%2Fpostget%2F</url>
    <content type="text"><![CDATA[什么是 HTTP？ 超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。 HTTP 的工作方式是客户机与服务器之间的请求-应答协议。 web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。 举例：客户端（浏览器）向服务器提交HTTP请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。GET请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：/test/demo_form.asp?name1=value1&amp;name2=value2 GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 POST 请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的： POST /test/demo_form.asp HTTP/1.1 Host: w3schools.com name1=value1&amp;name2=value2 POST 请求不会被缓存 POST 请求不会保留在浏览器历史记录中 POST 不能被收藏为书签 GET POST 请求对数据长度没有要求 … GET POST 后退按钮/刷新 可收藏为书签 不可收藏为书签 书签 能被缓存 不能缓存 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中 参数不会保存在浏览器历史中 对数据长度的限制 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 无限制。 对数据类型的限制 只允许 ASCII 字符。 没有限制。也允许二进制数据。 安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是URL的一部分。在发送密码或其他敏感信息时绝不要使用 GET POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 可见性 数据在 URL 中对所有人都是可见的。 数据不会显示在 URL 中。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>post</tag>
        <tag>get</tag>
      </tags>
  </entry>
</search>
