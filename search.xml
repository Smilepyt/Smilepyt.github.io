<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[(转)理解 JavaScript 作用域]]></title>
    <url>%2F2018%2F07%2F24%2Fjs%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[简介JavaScript 有个特性称为作用域。尽管对于很多开发新手来说，作用域的概念不容易理解，我会尽可能地从最简单的角度向你解释它们。理解作用域能让你编写更优雅、错误更少的代码，并能帮助你实现强大的设计模式。 什么是作用域作用域是你的代码在运行时，各个变量、函数和对象的可访问性。换句话说，作用域决定了你的代码里的变量和其他资源在各个区域中的可见性。 为什么需要作用域？最小访问原则那么，限制变量的可见性，不允许你代码中所有的东西在任意地方都可用的好处是什么？其中一个优势，是作用域为你的代码提供了一个安全层级。计算机安全中，有个常规的原则是：用户只能访问他们当前需要的东西。 想想计算机管理员吧。他们在公司各个系统上拥有很多控制权，看起来甚至可以给予他们拥有全部权限的账号。假设你有一家公司，拥有三个管理员，他们都有系统的全部访问权限，并且一切运转正常。但是突然发生了一点意外，你的一个系统遭到恶意病毒攻击。现在你不知道这谁出的问题了吧？你这才意识到你应该只给他们基本用户的账号，并且只在需要时赋予他们完全的访问权。这能帮助你跟踪变化并记录每个人的操作。这叫做最小访问原则。眼熟吗？这个原则也应用于编程语言设计，在大多数编程语言（包括 JavaScript）中称为作用域，接下来我们就要学习它。 在你的编程旅途中，你会意识到作用域在你的代码中可以提升性能，跟踪 bug 并减少 bug。作用域还解决不同范围的同名变量命名问题。记住不要弄混作用域和上下文。它们是不同的特性。 JavaScript中的作用域在 JavaScript 中有两种作用域 全局作用域 局部作用域 当变量定义在一个函数中时，变量就在局部作用域中，而定义在函数之外的变量则从属于全局作用域。每个函数在调用的时候会创建一个新的作用域。 全局作用域当你在文档中（document）编写 JavaScript 时，你就已经在全局作用域中了。JavaScript 文档中（document）只有一个全局作用域。定义在函数之外的变量会被保存在全局作用域中。 12// the scope is by default globalvar name = 'Hammad'; 全局作用域里的变量能够在其他作用域中被访问和修改。 123456789var name = 'Hammad'; console.log(name); // logs 'Hammad' function logName() &#123; console.log(name); // 'name' is accessible here and everywhere else&#125; logName(); // logs 'Hammad' 局部作用域定义在函数中的变量就在局部作用域中。并且函数在每次调用时都有一个不同的作用域。这意味着同名变量可以用在不同的函数中。因为这些变量绑定在不同的函数中，拥有不同作用域，彼此之间不能访问。 12345678910111213// Global Scopefunction someFunction() &#123; // Local Scope ##1 function someOtherFunction() &#123; // Local Scope ##2 &#125;&#125; // Global Scopefunction anotherFunction() &#123; // Local Scope ##3&#125;// Global Scope 块语句块级声明包括if和switch，以及for和while循环，和函数不同，它们不会创建新的作用域。在块级声明中定义的变量从属于该块所在的作用域。 123456if (true) &#123; // this 'if' conditional block doesn't create a new scope var name = 'Hammad'; // name is still in the global scope&#125; console.log(name); // logs 'Hammad' ECMAScript 6 引入了let和const关键字。这些关键字可以代替var。 1234var name = 'Hammad'; let likes = 'Coding';const skills = 'Javascript and PHP'; 和var关键字不同，let和const关键字支持在块级声明中创建使用局部作用域。 1234567891011121314if (true) &#123; // this 'if' conditional block doesn't create a scope // name is in the global scope because of the 'var' keyword var name = 'Hammad'; // likes is in the local scope because of the 'let' keyword let likes = 'Coding'; // skills is in the local scope because of the 'const' keyword const skills = 'JavaScript and PHP';&#125; console.log(name); // logs 'Hammad'console.log(likes); // Uncaught ReferenceError: likes is not definedconsole.log(skills); // Uncaught ReferenceError: skills is not defined 一个应用中全局作用域的生存周期与该应用相同。局部作用域只在该函数调用执行期间存在。 上下文很多开发者经常弄混作用域和上下文，似乎两者是一个概念。但并非如此。作用域是我们上面讲到的那些，而上下文通常涉及到你代码某些特殊部分中的this值。作用域指的是变量的可见性，而上下文指的是在相同的作用域中的this的值。我们当然也可以使用函数方法改变上下文，这个之后我们再讨论。在全局作用域中，上下文总是 Window 对象。 123456789// logs: Window &#123;speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage…&#125;console.log(this); function logFunction() &#123; console.log(this);&#125;// logs: Window &#123;speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage…&#125;// because logFunction() is not a property of an objectlogFunction(); 如果作用域定义在一个对象的方法中，上下文就是这个方法所在的那个对象。 1234567class User &#123; logName() &#123; console.log(this); &#125;&#125; (new User).logName(); // logs User &#123;&#125; (new User).logName()是创建对象关联到变量并调用logName方法的一种简便形式。通过这种方式你并不需要创建一个新的变量。 你可能注意到一点，就是如果你使用new关键字调用函数时上下文的值会有差异。上下文会设置为被调用的函数的实例。考虑一下上面的这个例子，用new关键字调用的函数。 12345function logFunction() &#123; console.log(this);&#125; new logFunction(); // logs logFunction &#123;&#125; 当在严格模式（strict mode）中调用函数时，上下文默认是 undefined。 执行环境为了解决掉我们从上面学习中会出现的各种困惑，“执行环境（context）”这个词中的“环境（context）”指的是作用域而并非上下文。这是一个怪异的命名约定，但由于 JavaScript 的文档如此，我们只好也这样约定。 JavaScript 是一种单线程语言，所以它同一时间只能执行单个任务。其他任务排列在执行环境中。当 JavaScript 解析器开始执行你的代码，环境（作用域）默认设为全局。全局环境添加到你的执行环境中，事实上这是执行环境里的第一个环境。 之后，每个函数调用都会添加它的环境到执行环境中。无论是函数内部还是其他地方调用函数，都会是相同的过程。 每个函数都会创建它自己的执行环境。 当浏览器执行完环境中的代码，这个环境会从执行环境中弹出，执行环境中当前环境的状态会转移到父级环境。浏览器总是先执行在执行栈顶的执行环境（事实上就是你代码最里层的作用域）。 全局环境只能有一个，函数环境可以有任意多个。执行环境有两个阶段：创建和执行。 创建阶段第一阶段是创建阶段，是函数刚被调用但代码并未执行的时候。创建阶段主要发生了 3 件事。 创建变量对象 创建作用域链 设置上下文（this）的值 变量对象变量对象（Variable Object）也称为活动对象（activation object），包含所有变量、函数和其他在执行环境中定义的声明。当函数调用时，解析器扫描所有资源，包括函数参数、变量和其他声明。当所有东西装填进一个对象，这个对象就是变量对象。 123'variableObject': &#123; // contains function arguments, inner variable and function declarations&#125; 作用域链在执行环境创建阶段，作用域链在变量对象之后创建。作用域链包含变量对象。作用域链用于解析变量。当解析一个变量时，JavaScript 开始从最内层沿着父级寻找所需的变量或其他资源。作用域链包含自己执行环境以及所有父级环境中包含的变量对象。 123'scopeChain': &#123; // contains its own variable object and other variable objects of the parent execution contexts&#125; 执行环境对象执行环境可以用下面抽象对象表示： 12345executionContextObject = &#123; 'scopeChain': &#123;&#125;, // contains its own variableObject and other variableObject of the parent execution contexts 'variableObject': &#123;&#125;, // contains function arguments, inner variable and function declarations 'this': valueOfThis&#125; 代码执行阶段执行环境的第二个阶段就是代码执行阶段，进行其他赋值操作并且代码最终被执行。 词法作用域词法作用域的意思是在函数嵌套中，内层函数可以访问父级作用域的变量等资源。这意味着子函数词法绑定到了父级执行环境。词法作用域有时和静态作用域有关。 12345678910111213function grandfather() &#123; var name = 'Hammad'; // likes is not accessible here function parent() &#123; // name is accessible here // likes is not accessible here function child() &#123; // Innermost level of the scope chain // name is also accessible here var likes = 'Coding'; &#125; &#125;&#125; 你可能注意到了词法作用域是向前的，意思是子执行环境可以访问name。但不是由父级向后的，意味着父级不能访问likes。这也告诉了我们，在不同执行环境中同名变量优先级在执行栈由上到下增加。一个变量和另一个变量同名，内层函数（执行栈顶的环境）有更高的优先级。 闭包闭包的概念和我们刚学习的词法作用域紧密相关。当内部函数试着访问外部函数的作用域链（词法作用域之外的变量）时产生闭包。闭包包括它们自己的作用域链、父级作用域链和全局作用域。 闭包不仅能访问外部函数的变量，也能访问外部函数的参数。 即使函数已经return，闭包仍然能访问外部函数的变量。这意味着return的函数允许持续访问外部函数的所有资源。 当你的外部函数return一个内部函数，调用外部函数时return的函数并不会被调用。你必须先用一个单独的变量保存外部函数的调用，然后将这个变量当做函数来调用。看下面这个例子： 1234567891011121314function greet() &#123; name = 'Hammad'; return function () &#123; console.log('Hi ' + name); &#125;&#125; greet(); // nothing happens, no errors // the returned function from greet() gets saved in greetLettergreetLetter = greet(); // calling greetLetter calls the returned function from the greet() functiongreetLetter(); // logs 'Hi Hammad' 值得注意的是，即使在greet函数return后，greetLetter函数仍可以访问greet函数的name变量。如果不使用变量赋值来调用greet函数return的函数，一种方法是使用()两次()()，如下所示： 12345678function greet() &#123; name = 'Hammad'; return function () &#123; console.log('Hi ' + name); &#125;&#125; greet()(); // logs 'Hi Hammad' 共有作用域和私有作用域在许多其他编程语言中，你可以通过 public、private 和 protected 作用域来设置类中变量和方法的可见性。看下面这个 PHP 的例子 1234567891011121314151617// Public Scopepublic $property;public function method() &#123; // ...&#125; // Private Sccpeprivate $property;private function method() &#123; // ...&#125; // Protected Scopeprotected $property;protected function method() &#123; // ...&#125; 将函数从公有（全局）作用域中封装，使它们免受攻击。但在 JavaScript 中，没有 共有作用域和私有作用域。然而我们可以用闭包实现这一特性。为了使每个函数从全局中分离出去，我们要将它们封装进如下所示的函数中： 123(function () &#123; // private scope&#125;)(); 函数结尾的括号告诉解析器立即执行此函数。我们可以在其中加入变量和函数，外部无法访问。但如果我们想在外部访问它们，也就是说我们希望它们一部分是公开的，一部分是私有的。我们可以使用闭包的一种形式，称为模块模式（Module Pattern），它允许我们用一个对象中的公有作用域和私有作用域来划分函数。 模块模式模块模式如下所示： 1234567891011var Module = (function() &#123; function privateMethod() &#123; // do something &#125; return &#123; publicMethod: function() &#123; // can call privateMethod(); &#125; &#125;;&#125;)(); Module 的return语句包含了我们的公共函数。私有函数并没有被return。函数没有被return确保了它们在 Module 命名空间无法访问。但我们的共有函数可以访问我们的私有函数，方便它们使用有用的函数、AJAX 调用或其他东西。 12Module.publicMethod(); // worksModule.privateMethod(); // Uncaught ReferenceError: privateMethod is not defined 一种习惯是以下划线作为开始命名私有函数，并返回包含共有函数的匿名对象。这使它们在很长的对象中很容易被管理。向下面这样： 1234567891011var Module = (function () &#123; function _privateMethod() &#123; // do something &#125; function publicMethod() &#123; // do something &#125; return &#123; publicMethod: publicMethod, &#125;&#125;)(); 立即执行函数表达式（IIFE）另一种形式的闭包是立即执行函数表达式（Immediately-Invoked Function Expression，IIFE）。这是一种在 window 上下文中自调用的匿名函数，也就是说this的值是window。它暴露了一个单一全局接口用来交互。如下所示： 123(function(window) &#123; // do anything&#125;)(this); 使用 .call()， .apply() 和 .bind() 改变上下文Call 和 Apply 函数来改变函数调用时的上下文。这带给你神奇的编程能力（和终极统治世界的能力）。你只需要使用 call 和 apply 函数并把上下文当做第一个参数传入，而不是使用括号来调用函数。函数自己的参数可以在上下文后面传入。 1234567function hello() &#123; // do something...&#125;hello(); // the way you usually call ithello.call(context); // here you can pass the context(value of this) as the first argumenthello.apply(context); // here you can pass the context(value of this) as the first argument .call()和.apply()的区别是 Call 中其他参数用逗号分隔传入，而 Apply 允许你传入一个参数数组。 12345678910111213141516function introduce(name, interest) &#123; console.log('Hi! I'm '+ name +' and I like '+ interest +'.'); console.log('The value of this is '+ this +'.')&#125; introduce('Hammad', 'Coding'); // the way you usually call itintroduce.call(window, 'Batman', 'to save Gotham'); // pass the arguments one by one after the contexttintroduce.apply('Hi', ['Bruce Wayne', 'businesses']); // pass the arguments in an array after the context // Output:// Hi! I'm Hammad and I like Coding.// The value of this is [object Window].// Hi! I'm Batman and I like to save Gotham.// The value of this is [object Window].// Hi! I'm Bruce Wayne and I like businesses.// The value of this is Hi. Call 比 Apply 的效率高一点。 下面这个例子列举文档中所有项目，然后依次在控制台打印出来。 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Things to learn&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Things to Learn to Rule the World&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Learn PHP&lt;/li&gt; &lt;li&gt;Learn Laravel&lt;/li&gt; &lt;li&gt;Learn JavaScript&lt;/li&gt; &lt;li&gt;Learn VueJS&lt;/li&gt; &lt;li&gt;Learn CLI&lt;/li&gt; &lt;li&gt;Learn Git&lt;/li&gt; &lt;li&gt;Learn Astral Projection&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // Saves a NodeList of all list items on the page in listItems var listItems = document.querySelectorAll('ul li'); // Loops through each of the Node in the listItems NodeList and logs its content for (var i = 0; i &lt; listItems.length; i++) &#123; (function () &#123; console.log(this.innerHTML); &#125;).call(listItems[i]); &#125; // Output logs: // Learn PHP // Learn Laravel // Learn JavaScript // Learn VueJS // Learn CLI // Learn Git // Learn Astral Projection &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML文档中仅包含一个无序列表。JavaScript 从 DOM 中选取它们。列表项会被从头到尾循环一遍。在循环时，我们把列表项的内容输出到控制台。 输出语句包含在由括号包裹的函数中，然后调用call函数。相应的列表项传入 call 函数，确保控制台输出正确对象的 innerHTML。 对象可以有方法，同样函数对象也可以有方法。事实上，JavaScript 函数有 4 个内置方法： Function.prototype.apply() Function.prototype.bind() (Introduced in ECMAScript 5 (ES5)) Function.prototype.call() Function.prototype.toString() Function.prototype.toString()返回函数代码的字符串表示。 到现在为止，我们讨论了.call()、.apply()和toString()。与 Call 和 Apply 不同，Bind 并不是自己调用函数，它只是在函数调用之前绑定上下文和其他参数。在上面提到的例子中使用 Bind： 12345678(function introduce(name, interest) &#123; console.log('Hi! I'm '+ name +' and I like '+ interest +'.'); console.log('The value of this is '+ this +'.')&#125;).bind(window, 'Hammad', 'Cosmology')(); // logs:// Hi! I'm Hammad and I like Cosmology.// The value of this is [object Window]. Bind 像call函数一样用逗号分隔其他传入参数，不像apply那样用数组传入参数。 完 转自前端大全，编译：伯乐在线/孙腾浩]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios.js学习]]></title>
    <url>%2F2018%2F07%2F18%2FAxios-js%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[简介Promise based HTTP client for the browser and node.jsaxios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 特征： 从浏览器中创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求数据和响应数据 取消请求 自动转换 JSON 数据 客户端支持防御 XSRF 安装：12345npm install axiosorbower install axiosor&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 样例执行GET请求 1234567891011121314151617181920212223242526272829303132333435363738394041const axios = require('axios');// Make a request for a user with a given IDaxios.get('/user?ID=12345') .then(function (response) &#123; // handle success console.log(response); &#125;) .catch(function (error) &#123; // handle error console.log(error); &#125;) .then(function () &#123; // always executed &#125;);// Optionally the request above could also be done asaxios.get('/user', &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;) .then(function () &#123; // always executed &#125;); // Want to use async/await? Add the `async` keyword to your outer function/method.async function getUser() &#123; try &#123; const response = await axios.get('/user?ID=12345'); console.log(response); &#125; catch (error) &#123; console.error(error); &#125;&#125; 提示：async/await 是ES7中的一部分，在Internet Explorer和老版本版浏览器中不支持，因此请谨慎使用。 执行POST请求 12345678910axios.post('/user', &#123; firstName: 'Fred', lastName: 'Flintstone' &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行多个并发请求 123456789101112function getUserAccount() &#123; return axios.get('/user/12345');&#125;function getUserPermissions() &#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // Both requests are now complete &#125;)); 配置普通配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import axios from 'axios' //引用axiosimport &#123;Promise&#125; from 'es6-promise' //引入Promise// axios 配置axios.defaults.timeout = 5000; //设置超时时间axios.defaults.baseURL = 'http://localhost:4000/api/v1/'; //这是调用数据接口// http request 拦截器（所有发送的请求都要从这儿过一次），通过这个，我们就可以把token传到后台，我这里是使用sessionStorage来存储token等权限信息和用户信息，若要使用cookie可以自己封装一个函数并import便可使用axios.interceptors.request.use( config =&gt; &#123; const token = sessionStorage.getItem("token"); //获取存储在本地的token config.data = JSON.stringify(config.data); config.headers = &#123; 'Content-Type':'application/json' //设置跨域头部,虽然很多浏览器默认都是使用json传数据，但咱要考虑IE浏览器。 &#125;; if (token) &#123; config.headers.Authorization = "Token " + token; //携带权限参数 &#125; return config; &#125;, err =&gt; &#123; return Promise.reject(err); &#125;);// http response 拦截器（所有接收到的请求都要从这儿过一次）axios.interceptors.response.use( response =&gt; &#123;//response.status===401是我和后台约定的权限丢失或者权限不够返回的状态码，这个可以自己和后台约定，约定返回某个自定义字段也是可以的 if(response.status == 401) &#123; router.push(&#123; //push后面是一个参数对象，可以携带很多参数，具体可以去vue-router上查看，例如query字段表示携带的参数 path: '/login' &#125;) &#125; return response; &#125;, error =&gt; &#123; return Promise.reject(error.response.data) &#125;);export default axios;/** * fetch 请求方法 * @param url * @param params * @returns &#123;Promise&#125; */export function fetch(url, params = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.get(url, &#123; params: params &#125;) .then(response =&gt; &#123; resolve(response.data); &#125;) .catch(err =&gt; &#123; reject(err) &#125;) &#125;)&#125;/** * post 请求方法 * @param url * @param data * @returns &#123;Promise&#125; */export function post(url, data = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(url, data) .then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err); &#125;) &#125;)&#125;/** * patch 方法封装 * @param url * @param data * @returns &#123;Promise&#125; */export function patch(url, data = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.patch(url, data) .then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err); &#125;) &#125;)&#125;/** * put 方法封装 * @param url * @param data * @returns &#123;Promise&#125; */export function put(url, data = &#123;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.put(url, data) .then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err); &#125;) &#125;)&#125; 动态配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import axios from 'axios' //引用axiosimport &#123;Promise&#125; from 'es6-promise' //引入Promise// axios 配置和拦截器都不用了，这里我使用了一个动态配置数据请求地址，在App.vue中，代码在下面，这个也不是必须的。//^_^下面都设置一个默认的头部，使用的时候可以传入数据覆盖^_^,例如使用fetch(GET)方法时，没有请求数据，但是请求头有变化，则应写成 fetch("地址", &#123;&#125;, &#123;"这里写头部的内容"&#125;) 记住没数据用一个空对象占位置/** * fetch 请求方法 * @param url * @param params * @returns &#123;Promise&#125; */export function fetch(url, params = &#123;&#125;, headers = &#123; 'Content-Type': 'application/json', //设置跨域头部 "Authorization": 'JWT ' + sessionStorage.getItem("authToken")&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.get(url, &#123; params: params, headers: headers &#125;) .then(response =&gt; &#123; resolve(response.data); &#125;) .catch(err =&gt; &#123; reject(err.response) &#125;) &#125;)&#125;/** * post 请求方法 * @param url * @param data * @returns &#123;Promise&#125; */export function post(url, data = &#123;&#125;, config = &#123; "headers": &#123; 'Content-Type': 'application/json', //设置跨域头部 "Authorization": 'JWT ' + sessionStorage.getItem("authToken") &#125;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.post(url, data, config) .then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err.response); &#125;) &#125;)&#125;/** * patch 方法封装 * @param url * @param data * @returns &#123;Promise&#125; */export function patch(url, data = &#123;&#125;, config = &#123; "headers": &#123; 'Content-Type': 'application/json', //设置跨域头部 "Authorization": 'JWT ' + sessionStorage.getItem("authToken") &#125;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.patch(url, data, config) .then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err.response); &#125;) &#125;)&#125;/** * put 方法封装 * @param url * @param data * @returns &#123;Promise&#125; */export function put(url, data = &#123;&#125;, config = &#123; "headers": &#123; 'Content-Type': 'application/json', //设置跨域头部 "Authorization": 'JWT ' + sessionStorage.getItem("authToken") &#125;&#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; axios.put(url, data, config) .then(response =&gt; &#123; resolve(response.data); &#125;, err =&gt; &#123; reject(err.response); &#125;) &#125;)&#125; 使用： 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div id="app"&gt; &lt;router-view/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import axios from 'axios';let protocol = window.location.protocol; //协议let host = window.location.host; //主机let reg = /^localhost+/;if(reg.test(host)) &#123; //若本地项目调试使用 axios.defaults.baseURL = 'http://xx.xx.xx.xx:xxxx/api/';&#125; else &#123; //动态请求地址 axios.defaults.baseURL = protocol + "//" + host + "/api/";&#125;axios.defaults.timeout = 30000;export default &#123; name: 'app', axios //这里记得导出，若请求地址永久固定一个，则就按照`普通版`配置一个baserURL就可以了&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 总结在使用动态版时，为什么称为动态呢，是因为访问地址和请求地址是同一个地址可端口号，例如我通过http://www.xxxx.com(默认端口80)访问项目，那么我的baseURL会自动的变为http//:www.xxxx.com:80/api/，这么做的原因是当某一天项目迁移或者http改为https时，不用你再去更改请求地址，程序自动就完成了。 假如数据请求地址配置不正确，如果你配置了baseURL，那么你封装的函数在使用时仅需传入基于baseURL的请求地址，例如传入login/那么请求地址会自动变为http://www.xxxx.com:80/api/login/，若未配置，那么可以直接传入整个请求地址 在使用动态版时，由于没有使用拦截器，所以下面封装的函数在返回错误的时候需要写成err.response.data来获取返回的数据，但我写的是err.response，因为这样可以拿到(status)状态码等信息，若不需要判断返回的状态码，则改为err.response.data便可 参考 Axios.js上手和动态Axios配置 github-axios]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6核心内容]]></title>
    <url>%2F2018%2F07%2F10%2FES6%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[ES6简介ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。也就是说，ES6就是ES2015。 最常用的ES6特性let, const, class, extends, super, arrow functions, template string, destructuring, default, rest arguments let,const123456789var name = 'zach'while (true) &#123; var name = 'pyt' console.log(name) //pyt break&#125;console.log(name) //pyt 使用var两次输出都是pyt，这是因为ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景就是你现在看到的内层变量覆盖外层变量。而let则实际上为JavaScript新增了块级作用域。用它所声明的变量，只在let命令所在的代码块内有效。 123456789let name = 'pan'while (true) &#123; let name = 'zhou' console.log(name) //zhou break&#125;console.log(name) //pan 另外一个var带来的不合理场景就是用来计数的循环变量泄露为全局变量，看下面的例子： 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。 123const PI = Math.PIPI = 23 //Module build failed: SyntaxError: /es6/app.js: "PI" is read-only class, extends, superES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。 123456789101112131415161718192021class Animal &#123; constructor()&#123; this.type = 'animal' &#125; says(say)&#123; console.log(this.type + ' says ' + say) &#125;&#125;let animal = new Animal()animal.says('hello') //animal says helloclass Cat extends Animal &#123; constructor()&#123; super() this.type = 'cat' &#125;&#125;let cat = new Cat()cat.says('hello') //cat says hello 上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。 Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Cat类，该类通过extends关键字，继承了Animal类的所有属性和方法。 super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 arrow function这个恐怕是ES6最最常用的一个新特性了，用它来写function比原来的写法要简洁清晰很多: 12345678910function(i)&#123; return i + 1; &#125; //ES5(i) =&gt; i + 1 //ES6function(x, y) &#123; x++; y--; return x + y;&#125;(x, y) =&gt; &#123;x++; y--; return x+y&#125; 除了看上去更简洁以外，arrow function还有一项超级无敌的功能！长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。例如： 12345678910111213class Animal &#123; constructor()&#123; this.type = 'animal' &#125; says(say)&#123; setTimeout(function()&#123; console.log(this.type + ' says ' + say) &#125;, 1000) &#125;&#125; var animal = new Animal() animal.says('hi') //undefined says hi 运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象。所以为了让它能够正确的运行，传统的解决方法有两种： 第一种是将this传给self,再用self来指代this 123456says(say)&#123; var self = this; setTimeout(function()&#123; console.log(self.type + ' says ' + say) &#125;, 1000)&#125; 第二种方法是用bind(this),即 12345says(say)&#123; setTimeout(function()&#123; console.log(this.type + ' says ' + say) &#125;.bind(this), 1000)&#125; 但现在我们有了箭头函数，就不需要这么麻烦了： 123456789101112class Animal &#123; constructor()&#123; this.type = 'animal' &#125; says(say)&#123; setTimeout( () =&gt; &#123; console.log(this.type + ' says ' + say) &#125;, 1000) &#125;&#125; var animal = new Animal() animal.says('hi') //animal says hi 当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。 template string当我们要插入大段的html内容到文档中时，传统的写法非常麻烦，所以之前我们通常会引用一些模板工具库，比如mustache等等。以前的代码，我们要用一堆的’+’号来连接文本与变量：123456$("#result").append( "There are &lt;b&gt;" + basket.count + "&lt;/b&gt; " + "items in your basket, " + "&lt;em&gt;" + basket.onSale + "&lt;/em&gt; are on sale!"); now，使用ES6的新特性模板字符串12345$("#result").append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 用反引号（``）来标识起始，用${}来引用变量，而且所有的空格和缩进都会被保留在输出之中。 destructuringES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。例如： 1234let cat = 'ken'let dog = 'lili'let zoo = &#123;cat: cat, dog: dog&#125;console.log(zoo) //Object &#123;cat: "ken", dog: "lili"&#125; 12345678910//ES6let cat = 'ken'let dog = 'lili'let zoo = &#123;cat, dog&#125;console.log(zoo) //Object &#123;cat: "ken", dog: "lili"&#125;//反过来可以这么写：let dog = &#123;type: 'animal', many: 2&#125;let &#123; type, many&#125; = dogconsole.log(type, many) //animal 2 default, restdefault很简单，意思就是默认值。大家可以看下面的例子，调用animal()方法时忘了传参数，传统的做法就是加上这一句type = type || &#39;cat&#39; 来指定默认值。 12345function animal(type)&#123; type = type || 'cat' console.log(type)&#125;animal() 最后一个rest语法也很简单，直接看例子： 1234function animals(...types)&#123; console.log(types)&#125;animals('cat', 'dog', 'fish') //["cat", "dog", "fish"] 而如果不用ES6的话，我们则得使用ES5的arguments。 import export这两个家伙对应的就是es6自己的module功能。 我们之前写的Javascript一直都没有模块化的体系，无法将一个庞大的js工程拆分成一个个功能相对独立但相互依赖的小工程，再用一种简单的方法把这些小工程连接在一起。 这有可能导致两个问题： 1.一方面js代码变得很臃肿，难以维护 2.另一方面我们常常得很注意每个script标签在html中的位置，因为它们通常有依赖关系，顺序错了可能就会出bug 在es6之前为解决上面提到的问题，我们得利用第三方提供的一些方案，主要有两种CommonJS(服务器端)和AMD（浏览器端，如require.js）。 而现在我们有了es6的module功能，它实现非常简单，可以成为服务器和浏览器通用的模块解决方案。 ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。 首先我们回顾下require.js的写法。假设我们有两个js文件: index.js和content.js,现在我们想要在index.js中使用content.js返回的结果，我们要怎么做呢？ 首先定义：1234//content.jsdefine('content.js', function()&#123; return 'A cat';&#125;) 然后require：1234//index.jsrequire(['./content.js'], function(animal)&#123; console.log(animal); //A cat&#125;) 那CommonJS是怎么写的呢？12345//index.jsvar animal = require('./content.js')//content.jsmodule.exports = 'A cat' ES6的写法12345//index.jsimport animal from './content'//content.jsexport default 'A cat' ES6 module的其他高级用法1234567//content.jsexport default 'A cat' export function say()&#123; return 'Hello!'&#125; export const type = 'dog' 上面可以看出，export命令除了输出变量，还可以输出函数，甚至是类12345//index.jsimport &#123; say, type &#125; from './content' let says = say()console.log(`The $&#123;type&#125; says $&#123;says&#125;`) //The dog says Hello 这里输入的时候要注意：大括号里面的变量名，必须与被导入模块（content.js）对外接口的名称相同。 如果还希望输入content.js中输出的默认值(default), 可以写在大括号外面。123456//index.jsimport animal, &#123; say, type &#125; from './content' let says = say()console.log(`The $&#123;type&#125; says $&#123;says&#125; to $&#123;animal&#125;`) //The dog says Hello to A cat 修改变量名：此时我们不喜欢type这个变量名，因为它有可能重名，所以我们需要修改一下它的变量名。在es6中可以用as实现一键换名。123456//index.jsimport animal, &#123; say, type as animalType &#125; from './content' let says = say()console.log(`The $&#123;animalType&#125; says $&#123;says&#125; to $&#123;animal&#125;`) //The dog says Hello to A cat 模块的整体加载：除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。12345//index.jsimport animal, * as content from './content' let says = content.say()console.log(`The $&#123;content.type&#125; says $&#123;says&#125; to $&#123;animal&#125;`) //The dog says Hello to A cat 通常星号*结合as一起使用比较合适。 考虑下面的场景：上面的content.js一共输出了三个变量（default, say, type）,假如我们的实际项目当中只需要用到type这一个变量，其余两个我们暂时不需要。我们可以只输入一个变量：1import &#123; type &#125; from './content' 由于其他两个变量没有被使用，我们希望代码打包的时候也忽略它们，抛弃它们，这样在大项目中可以显著减少文件的体积。 参考文章 https://segmentfault.com/a/1190000004365693 https://segmentfault.com/a/1190000004368132]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack简单搭建]]></title>
    <url>%2F2018%2F07%2F02%2Fwebpack%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Webpack4 简单搭建webpack简介本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 四个核心概念： 入口(entry) 输出(output) loader 插件(plugins) webpack中文网：https://webpack.docschina.org npm简介npm 是JavaScript 世界的包管理工具，并且是Node.js 平台的默认包管理工具。通过npm 可以安装、共享、分发代码，管理项目依赖关系。 npm中文网：https://www.npmjs.com.cn npm装包时的区别 -D -S -g我们在使用npm install 安装模块或插件的时候，有两种命令把他们写入到 package.json 文件里面去，比如：1```--save 在 package.json 文件里面提现出来的区别就是，使用 –save-dev 安装的 插件，被写入到devDependencies 对象里面去，而使用 –save 安装的插件，责被写入到 dependencies 对象里面去。那 package.json 文件里面的 devDependencies 和 dependencies 对象有什么区别呢？devDependencies 里面的插件只用于开发环境，不用于生产环境，而 dependencies 是需要发布到生产环境的。12345678910npm i module_name -S =&gt; npm install module_name --save 写入到 dependencies 对象 ornpm i -S module_name npm i module_name -D ==&gt; npm install module_name --save-dev 写入到 devDependencies 对象 ornpm i -D module_name npm i module_name -g 全局安装 i 是install 的简写 备注：详细信息可以用 help install``` 查看123456## webpack4 基础配置### 安装webpack、webpack-cli、webpack-dev-server- NPM初始化```npm init 本地局部安装webpack、webpack-clii webpack webpack-cli -D```12安装成功后 “devDependencies”: {“webpack”: “^4.14.0”,“webpack-cli”: “^3.0.8”}12- 本地局部安装webpack-dev-server```npm i webpack-dev-server -D 12345&quot;devDependencies&quot;: &#123;&quot;webpack&quot;: &quot;^4.14.0&quot;,&quot;webpack-cli&quot;: &quot;^3.0.8&quot;,&quot;webpack-dev-server&quot;: &quot;^3.1.4&quot;&#125; 增加快速启动服务脚本12345&quot;scripts&quot;: &#123;&quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,&quot;dev&quot;: &quot;webpack-dev-server --open --config webpack.config.js&quot;,&quot;build&quot;: &quot;webpack --progress --hide-modules --config webpack.prod.config.js&quot;&#125;, 备注： IP和端口是可以配置的123&quot;scripts&quot;: &#123;&quot;dev&quot;: &quot;webpack-dev-server --host 172.172.172.1 --port 8888 --open --config webpack.config.js&quot;,&#125;, webpack和webpack-dev-server区别第一：webpack只是构建webpack-dev-server除了构建，还提供web服务第二：webpack.config.json的路径参数显然，entry都一样，因为都要知道需要构建的文件在哪里那么区别就在于 output了path和webpack一起，指明构建 之后 输出文件的位置，这是真实的物理地址 publickPath和webpack-dev-server一起，当执行webpack-dev-server时，第一步首先跟webpack一样，先构建输出，然后提供web访问，该输出文件是在内存中 默认情况下，不设置publicPath则输出文件默认在运行webpack-dev-server的目录，也就是根目录，，那么html中引用直接是src=”输出的文件”，，如果设置了publicPath那么html中引用也要相对改变 总的来说，webpack只是构建，而webpack-dev-server相当于webpack+apache（或者其它web服务器） 区别在于 使用webpack+apache（或者其它服务器），每次构建之后，首先1 根据path引用构建后的输出文件；2 每次修改都要重新运行webpack 使用webpack-dev-server，运行之后首先1 先构建，输出文件在内存中，引用构建后的输出文件根据publicPath（默认是根目录）；2 每次修改，自动刷新 webpack执行命令参数12345678webpack --config XXX.js //使用另一份配置文件（比如webpack.prod.config.js）来打包webpack --watch //监听变动并自动打包webpack --colors 配置打包输出颜色显示webpack -p//压缩混淆脚本，这个非常非常重要！webpack -d//生成map映射文件，告知哪些模块被最终打包到哪里了其中的 webpack --progress //显示进度条webpack --color //添加颜色webpack --hide-modules //隐藏来自文件夹的模块 配置文件添加webpack.config.js配置文件在webpack.config.js中进行入口和输出的配置123456789101112var path = require(&apos;path&apos;);var config = &#123; entry: &#123; main: &apos;./main&apos; &#125;, output: &#123; path: path.join(__dirname, &apos;./dist&apos;), publicPath: &apos;/dist/&apos;, filename: &apos;main.js&apos; &#125;&#125;;module.exports = config; 使用不同的加载器(Loaders)处理不同的模块 例如使用CSS样式：i css-loader -D```1```npm i style-loader -D 123456789101112131415var config = &#123; //... module: &#123; rules: [ &#123; test: /\.css$/, use: [ &apos;style-loader&apos;, &apos;css-loader&apos; ] &#125; ] &#125;&#125;;module.exports = config; 插件(Plugins)例如提取散落的CSS 安装extract-text-webpack-plugin插件1npm i extract-text-webpack-plugin -D 12345678910111213141516171819202122232425262728var path = require(&apos;path&apos;);var ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);var config = &#123; entry: &#123; main: &apos;./main&apos; &#125;, output: &#123; path: path.join(__dirname, &apos;./dist&apos;), publicPath: &apos;/dist/&apos;, filename: &apos;main.js&apos; &#125;, module: &#123; rules: [ &#123; test: /\.css$/, css: ExtractTextPlugin.extract(&#123; use: &apos;css-loader&apos;, fallback: &apos;style-loader&apos; &#125;) &#125; ] &#125;, plugins: [ new ExtractTextPlugin(&quot;main.css&quot;) ]&#125;;module.exports = config; 可能会遇到下面的错误1Error: Chunk.entrypoints: Use Chunks.groupsIterable and filter by instanceof Entrypoint instead 这个是由于版本的问题造成的，解决方法如下： npm install extract-text-webpack-plugin@next]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java生成PDF]]></title>
    <url>%2F2018%2F05%2F28%2Fjava%E7%94%9F%E6%88%90PDF%2F</url>
    <content type="text"><![CDATA[使用iText库创建PDF文件 iText是著名的开放项目，是用于生成PDF文档的一个java类库。通过iText不仅可以生成PDF或rtf的文档，而且可以将XML、Html文件转化为PDF文件。这里简单记录一下我对IText的使用。 项目依赖123456789101112131415161718//项目要使用iText，必须引入jar包。才能使用，maven依赖如下：&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itextpdf&lt;/artifactId&gt; &lt;version&gt;5.5.10&lt;/version&gt;&lt;/dependency&gt;//输出中文，还要引入下面itext-asian.jar包&lt;dependency&gt; &lt;groupId&gt;com.itextpdf&lt;/groupId&gt; &lt;artifactId&gt;itext-asian&lt;/artifactId&gt; &lt;version&gt;5.2.0&lt;/version&gt;&lt;/dependency&gt;//设置pdf文件密码，还要引入下面bcprov-jdk15on.jar包&lt;dependency&gt; &lt;groupId&gt;org.bouncycastle&lt;/groupId&gt; &lt;artifactId&gt;bcprov-jdk15on&lt;/artifactId&gt; &lt;version&gt;1.54&lt;/version&gt;&lt;/dependency&gt; iText常用的类 com.itextpdf.text.Document：这是iText库中最常用的类，它代表了一个pdf实例。如果你需要从零开始生成一个PDF文件，你需要使用这个Document类。首先创建（new）该实例，然后打开（open）它，并添加（add）内容，最后关闭（close）该实例，即可生成一个pdf文件。 com.itextpdf.text.Paragraph：表示一个缩进的文本段落，在段落中，你可以设置对齐方式，缩进，段落前后间隔等。 com.itextpdf.text.Chapter：表示PDF的一个章节，他通过一个Paragraph类型的标题和整形章数创建。 com.itextpdf.text.Font：这个类包含了所有规范好的字体，包括family of font，大小，样式和颜色，所有这些字体都被声明为静态常量。 com.itextpdf.text.List：表示一个列表； com.itextpdf.text.Anchor：表示一个锚，类似于HTML页面的链接。 com.itextpdf.text.pdf.PdfWriter：当这个PdfWriter被添加到PdfDocument后，所有添加到Document的内容将会写入到与文件或网络关联的输出流中。 com.itextpdf.text.pdf.PdfReader：用于读取PDF文件； 简单样例12345678910111213141516171819202122232425262728293031import java.io.FileNotFoundException;import java.io.FileOutputStream;import com.itextpdf.text.Document;import com.itextpdf.text.DocumentException;import com.itextpdf.text.Paragraph;import com.itextpdf.text.pdf.PdfWriter;public class TestPDFDemo1 &#123; public static void main(String[] args) throws FileNotFoundException, DocumentException &#123; // 1.新建document对象 Document document = new Document(); // 2.建立一个书写器(Writer)与document对象关联，通过书写器(Writer)可以将文档写入到磁盘中。 // 创建 PdfWriter 对象 第一个参数是对文档对象的引用，第二个参数是文件的实际名称，在该名称中还会给出其输出路径。 PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream("C:/Users/Ac__LBJ/Desktop/test.pdf")); // 3.打开文档 document.open(); // 4.添加一个内容段落 document.add(new Paragraph("Hello World!")); // 5.关闭文档 document.close(); &#125;&#125; 生成表格(含图片)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.party.www.util.pyt;import com.itextpdf.text.*;import com.itextpdf.text.pdf.BaseFont;import com.itextpdf.text.pdf.PdfPCell;import com.itextpdf.text.pdf.PdfPTable;import com.itextpdf.text.pdf.PdfWriter;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.net.URL;public class pytTest &#123; public static void main(String[] args) throws DocumentException, IOException &#123; //创建文件 Document document = new Document(); //建立一个书写器 PdfWriter writer = PdfWriter.getInstance(document, new FileOutputStream("C:\\Users\\Ac__LBJ\\Desktop\\b.pdf")); //打开文件 document.open(); //创建一个简体中文的基本字体、UniGB-UCS2-H为简体中文 BaseFont base = BaseFont.createFont("STSong-Light", "UniGB-UCS2-H",BaseFont.EMBEDDED); Font fontChinese = new Font(base, 12, Font.NORMAL); PdfPTable table = new PdfPTable(1); // 3 columns. table.setWidthPercentage(100); // Width 100% table.setSpacingBefore(10f); // Space before table table.setSpacingAfter(0); // Space after table PdfPCell cell1 = new PdfPCell(new Paragraph("标题：",fontChinese)); cell1.setBorder(0);//隐藏边框（设置边框宽度为0） PdfPCell cell11 = new PdfPCell(new Paragraph("西南科技大学党委书记祝贺骑士获得总冠军",fontChinese)); cell11.setBorder(0); PdfPCell cell2 = new PdfPCell(new Paragraph("内容：",fontChinese)); cell2.setBorder(0); PdfPCell cell22 = new PdfPCell(new Paragraph("西南科技大学党委书记祝贺骑士获得总冠军西南科技大学党委书记祝贺骑士获得总冠军",fontChinese)); cell22.setBorder(0); table.addCell(cell1); table.addCell(cell11); table.addCell(cell2); table.addCell(cell22); document.add(table); PdfPTable imgTable = new PdfPTable(3); // 3 columns. imgTable.setWidthPercentage(100); // Width 100% imgTable.setSpacingBefore(10f); // Space before table imgTable.setSpacingAfter(0); // Space after table imgTable.getDefaultCell().setBorder(0); for (int i =0 ;i&lt;6 ;i++)&#123; Image image = Image.getInstance("C:\\Users\\Ac__LBJ\\Desktop\\aaa.png"); imgTable.addCell(image); &#125; document.add(imgTable); //关闭文档 document.close(); //关闭书写器 writer.close(); &#125;&#125; 参考博客 https://www.cnblogs.com/chenpi/p/5534595.html#_label6 http://www.cnblogs.com/h--d/p/6150320.html http://rensanning.iteye.com/blog/1538689]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas简单学习]]></title>
    <url>%2F2018%2F05%2F27%2Fcanvas%E7%AE%80%E5%8D%95%E6%A0%B7%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Canvas基础简介12&lt;canvas&gt;是HTML5新增的元素，可用于通过使用JavaScript中的脚本来绘制图形。例如，它可以用于绘制图形，制作照片，创建动画，甚至可以进行实时视频处理或渲染。 1&lt;canvas id="tutorial" width="150" height="150"&gt;&lt;/canvas&gt; 12&lt;canvas&gt;看起来和&lt;img&gt;元素很相像，唯一的不同就是它并没有 src 和 alt 属性。实际上，&lt;canvas&gt; 标签只有两个属性—— width 和 height。 简单例子123456789101112131415161718192021&lt;html&gt; &lt;head&gt; &lt;script type="application/javascript"&gt; function draw() &#123; var canvas = document.getElementById("canvas"); if (canvas.getContext) &#123; var ctx = canvas.getContext("2d"); ctx.fillStyle = "rgb(200,0,0)"; ctx.fillRect (10, 10, 55, 50); ctx.fillStyle = "rgba(0, 0, 200, 0.5)"; ctx.fillRect (30, 30, 55, 50); &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload="draw();"&gt; &lt;canvas id="canvas" width="150" height="150"&gt;&lt;/canvas&gt; &lt;/body&gt;&lt;/html&gt; 像素操作1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Canvas学习&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="myCanvas" width="600" height="600" style="border:1px solid #d3d3d3;"&gt; 您的浏览器不支持 HTML5 canvas 标签。 &lt;/canvas&gt; &lt;script&gt; var c = document.getElementById("myCanvas"); var ctx = c.getContext("2d"); var imgData = ctx.createImageData(512, 512); for (var i = 0; i &lt; imgData.data.length; i += 4) &#123; imgData.data[i + 0] = 255; imgData.data[i + 1] = 0; imgData.data[i + 2] = 0; imgData.data[i + 3] = 255; &#125; // 将rgba数组一一赋值给imgData数组，注意：不能直接等，因为二者数组类型不一致 // for (var i = 0; i &lt; imgData.data.length; i++) &#123; // imgData.data[i] = myData[i]; // &#125; ctx.putImageData(imgData, 0, 0); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考学习 https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 文件上传]]></title>
    <url>%2F2017%2F12%2F27%2Ffileupload%2F</url>
    <content type="text"><![CDATA[Spring 文件上传 文件上传工具类 FileUploadUtil 1234567891011121314151617181920212223242526272829303132333435363738/** * 上传文件的公共方法 * @param uploadDir 上传文件目录 * @param file 上传对象 * @return 文件上传后的结果 * key = successFlag (boolean)表示文件是否上传成功 * key = fileName (String)表示文件的文件名 */public static Map&lt;String,Object&gt; executeUpload(String uploadDir, MultipartFile file)&#123; Map&lt;String,Object&gt; resultMap = new HashMap&lt;&gt;(); try &#123; //文件后缀名 String suffix = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(".")); //上传文件名 String filename = UUID.randomUUID() + suffix; //如果目录不存在，自动创建文件夹 File dir = new File(uploadDir); if(!dir.exists()) &#123; dir.mkdir(); &#125; //服务器端保存的文件对象 File serverFile = new File(uploadDir + filename); //将上传的文件写入到服务器端文件内 file.transferTo(serverFile); //打印文件存储信息 logger.info("文件上传成功，存储位置：&#123;&#125;&#123;&#125;",uploadDir,filename); //封装返回信息（是否成功标志、随机生成的文件名） resultMap.put("successFlag",true); resultMap.put("fileName",filename); &#125; catch (IOException e) &#123; e.printStackTrace(); logger.error("文件上传失败！"); resultMap.put("successFlag",false); &#125; return resultMap;&#125; 单文件上传方法1234567891011121314151617181920212223242526272829/** * 上传文件方法 * @param file 前台上传的文件对象 * @return */@RequestMapping(value = "/upload",method = RequestMethod.POST)@ResponseBodypublic Object upload(HttpServletRequest request, MultipartFile file)&#123; Map&lt;String,Object&gt; resultMap = new HashMap&lt;&gt;(); try &#123; //上传目录地址 String uploadDir = request.getSession().getServletContext().getRealPath("/") +"upload/"; //调用上传方法 Map&lt;String,Object&gt; ans = FileUploadUtil.executeUpload(uploadDir,file); if (ans.get("successFlag").equals(true))&#123; resultMap.put("name",ans.get("fileName")); &#125; else &#123; resultMap.put("msg","false"); &#125; &#125;catch (Exception e) &#123; //打印错误堆栈信息 e.printStackTrace(); resultMap.put("msg","false"); &#125; return resultMap;&#125; 多文件上传方法1234567891011121314151617181920212223242526272829303132333435363738/** * 上传多个文件 * @param request 请求对象 * @param file 上传文件集合 * @return */@RequestMapping(value = "/uploads",method = RequestMethod.POST)@ResponseBodypublic Object uploads(HttpServletRequest request,MultipartFile[] file)&#123; Map&lt;String,Object&gt; resultMap = new HashMap&lt;&gt;(); StringBuffer fileName = new StringBuffer(); try &#123; //上传目录地址 String uploadDir = request.getSession().getServletContext().getRealPath("/") +"upload/"; //遍历文件数组执行上传 for (int i =0;i&lt;file.length;i++) &#123; if(file[i] != null) &#123; //调用上传方法 Map&lt;String,Object&gt; ans = FileUploadUtil.executeUpload(uploadDir, file[i]); if (ans.get("successFlag").equals(true))&#123; if (i == file.length - 1) &#123; fileName.append(ans.get("fileName")); &#125; else &#123; fileName.append(ans.get("fileName") + ","); &#125; &#125; &#125; &#125; resultMap.put("name",fileName); &#125;catch (Exception e) &#123; //打印错误堆栈信息 e.printStackTrace(); resultMap.put("msg","false"); &#125; return resultMap;&#125; 文件下载 一般情况下，只需要将文件路径返回给前端，通过点击文件路径，就能实现文件下载。 12345678910111213141516171819202122232425262728293031323334353637383940414243@RequestMapping(value = "/download")@ResponseBodypublic void download(HttpServletRequest request, HttpServletResponse response)&#123; //System.out.println(name); String name = "16cd89a7-1160-4ec4-8ef5-4ad6f2e96002.doc"; try&#123; String uploadDir = request.getSession().getServletContext().getRealPath("/") +"upload/"; File file = new File(uploadDir + name); //判断文件是否存在 if(!file.exists()) &#123; return; &#125; //判断文件类型 String mimeType = URLConnection.guessContentTypeFromName(file.getName()); if(mimeType == null) &#123; mimeType = "application/octet-stream"; &#125; response.setContentType(mimeType); //设置文件响应大小 response.setContentLengthLong(file.length()); //文件名编码，解决乱码问题 String fileName = file.getName(); String encodedFileName = null; String userAgentString = request.getHeader("User-Agent"); String browser = UserAgent.parseUserAgentString(userAgentString).getBrowser().getGroup().getName(); if(browser.equals("Chrome") || browser.equals("Internet Exploer") || browser.equals("Safari")) &#123; encodedFileName = URLEncoder.encode(fileName,"utf-8").replaceAll("\\+", "%20"); &#125; else &#123; encodedFileName = MimeUtility.encodeWord(fileName); &#125; //设置Content-Disposition响应头，一方面可以指定下载的文件名，另一方面可以引导浏览器弹出文件下载窗口 response.setHeader("Content-Disposition", "attachment;fileName=\"" + encodedFileName + "\""); //文件下载 InputStream in = new BufferedInputStream(new FileInputStream(file)); FileCopyUtils.copy(in, response.getOutputStream()); &#125;catch (IOException e)&#123; &#125;&#125; 文件拷贝上的性能差异分析及参考文章 通过零拷贝实现有效数据传输 Java IO和Java NIO在文件拷贝上的性能差异分析 Java 复制大文件方式（nio2 FileChannel 拷贝文件能力测试） SpringMVC上传文件的三种方式 Spring MVC中优雅地进行文件下载以及下载文件名乱码的一些探讨 Springboot文件下载]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring 邮件服务]]></title>
    <url>%2F2017%2F12%2F27%2Fjavamail%2F</url>
    <content type="text"><![CDATA[对JavaMailSender用法做个简单的小结在Spring Boot的工程中的pom.xml中引入spring-boot-starter-mail依赖：12345&lt;!-- 邮件依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 12345&lt;!-- 模板引擎 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 在配置文件中添加相应的属性 在application.properties中 123456spring.mail.host=smtp.qq.comspring.mail.username=邮箱账号spring.mail.password=授权码（不是邮箱密码）spring.mail.properties.mail.smtp.auth=truespring.mail.properties.mail.smtp.starttls.enable=truespring.mail.properties.mail.smtp.starttls.required=true 在application.yml中 1234567891011121314mail: host: smtp.qq.com（QQ邮箱为例） username: 邮箱账号 password: 授权码（不是邮箱密码） default-encoding: UTF-8 fromMail: addr: 发送方邮箱 properties: mail: smtp: auth: true starttls: enable: true required: true 简单使用 由于Spring Boot的starter模块提供了自动化配置，所以在引入了spring-boot-starter-mail依赖之后，会根据配置文件中的内容去创建JavaMailSender实例，因此我们可以直接在需要使用的地方直接@Autowired来引入邮件发送对象。我们通过使用SimpleMailMessage实现了简单的邮件发送，也可以使用MimeMessage来设置复杂一些的邮件内容。 编写MailService和MailServiceImpl 编写MailService接口 123456789public interface MailService &#123; public void sendSimpleMail(String to, String subject, String content); public void sendHtmlMail(String to, String subject, String content); public void sendAttachmentsMail(String to, String subject, String content, String filePath); public void sendInlineResourceMail(String to, String subject, String content, String rscPath, String rscId);&#125; 编写MailServiceImpl实现类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118@Servicepublic class MailServiceImpl implements MailService&#123; private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private JavaMailSender mailSender;// @Value("$&#123;mail.fromMail.addr&#125;")// private String from; private String from = "1006936991@qq.com"; /** * 发送文本邮件 * @param to 目标邮箱 * @param subject 邮件主题 * @param content 邮件内容 */ @Override public void sendSimpleMail(String to, String subject, String content) &#123; SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(from); message.setTo(to); message.setSubject(subject); message.setText(content); try &#123; mailSender.send(message); logger.info("简单邮件已经发送。"); &#125; catch (Exception e) &#123; logger.error("发送简单邮件时发生异常！", e); &#125; &#125; /** * 发送html邮件 * @param to * @param subject * @param content */ @Override public void sendHtmlMail(String to, String subject, String content) &#123; MimeMessage message = mailSender.createMimeMessage(); try &#123; //true表示需要创建一个multipart message MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); mailSender.send(message); logger.info("html邮件发送成功"); &#125; catch (MessagingException e) &#123; logger.error("发送html邮件时发生异常！", e); &#125; &#125; /** * 发送带附件的邮件 * @param to * @param subject * @param content * @param filePath */ public void sendAttachmentsMail(String to, String subject, String content, String filePath)&#123; MimeMessage message = mailSender.createMimeMessage(); try &#123; MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); FileSystemResource file = new FileSystemResource(new File(filePath)); String fileName = filePath.substring(filePath.lastIndexOf(File.separator)); helper.addAttachment(fileName, file); //helper.addAttachment("test"+fileName, file); mailSender.send(message); logger.info("带附件的邮件已经发送。"); &#125; catch (MessagingException e) &#123; logger.error("发送带附件的邮件时发生异常！", e); &#125; &#125; /** * 发送正文中有静态资源（图片）的邮件 * @param to * @param subject * @param content * @param rscPath * @param rscId */ public void sendInlineResourceMail(String to, String subject, String content, String rscPath, String rscId) &#123; MimeMessage message = mailSender.createMimeMessage(); try &#123; MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); FileSystemResource res = new FileSystemResource(new File(rscPath)); helper.addInline(rscId, res); mailSender.send(message); logger.info("嵌入静态资源的邮件已经发送。"); &#125; catch (MessagingException e) &#123; logger.error("发送嵌入静态资源的邮件时发生异常！", e); &#125; &#125;&#125; 测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.smile.service;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import org.thymeleaf.TemplateEngine;import org.thymeleaf.context.Context;/** * Created by pyt on 2017/12/26/0026. */@RunWith(SpringRunner.class)@SpringBootTestpublic class MailServiceTest &#123; @Autowired private MailService mailService; @Autowired private TemplateEngine templateEngine; @Test public void testSimpleMail() throws Exception &#123; mailService.sendSimpleMail("307080368@qq.com","test simple mail"," pyt,this is simple mail"); &#125; @Test public void testHtmlMail() throws Exception &#123; String content="&lt;html&gt;\n" + "&lt;body&gt;\n" + " &lt;h3&gt;hello world ! 这是一封html邮件!&lt;/h3&gt;\n" + "&lt;/body&gt;\n" + "&lt;/html&gt;"; mailService.sendHtmlMail("307080368@qq.com","test simple mail",content); &#125; @Test public void sendAttachmentsMail() &#123; String filePath="F:\\javaPhotoTest\\LearnDo\\1513167730446da70.doc"; mailService.sendAttachmentsMail("307080368@qq.com", "主题：带附件的邮件", "涛哥有附件，请查收！", filePath); &#125; @Test public void sendInlineResourceMail() &#123; String rscId = "myImg"; String content="&lt;html&gt;&lt;body&gt;这是有图片的邮件：&lt;img src=\'cid:" + rscId + "\' &gt;&lt;/body&gt;&lt;/html&gt;"; String imgPath = "F:\\javaPhotoTest\\InnerParty\\1513761305358f62a.jpg"; mailService.sendInlineResourceMail("307080368@qq.com", "主题：这是有图片的邮件", content, imgPath, rscId); &#125; @Test public void sendTemplateMail() &#123; //创建邮件正文 Context context = new Context(); context.setVariable("id", "1"); String emailContent = templateEngine.process("emailTemplate", context); mailService.sendHtmlMail("307080368@qq.com","主题：这是模板邮件",emailContent); &#125;&#125; 备注: 12345html语言可以带上图片链接&lt;img src=&quot;c:/test.jpg&quot;&gt; &lt;/img&gt;那么我们在发送邮件的时候就需要对这些链接的图片做特殊处理,否则在对方接收到邮件的时候会看不到图片。我们特殊处理的方法就是把它们当成附件发送，但不显示在附件里。要做到这些就首先需要对输入的content进行解析，找到所带图片的路径。然后把content中&lt;img src=&quot;c:/test.jpg&quot;&gt; &lt;/img&gt; 这段代码变成&lt;img src=&quot;cid:IMG&quot;&gt; &lt;/img&gt; Spring Boot中开发Web应用时，模板默认位于resources/templates/目录下，可以添加邮件模板 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="zh" xmlns:th="http://www.thymeleaf.org"&gt; &lt;head&gt; &lt;meta charset="UTF-8"/&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 您好,这是验证邮件,请点击下面的链接完成验证,&lt;br/&gt; &lt;!--&lt;a href="#" th:href="@&#123; http://www.panyutao.top/&#123;id&#125;(id=$&#123;id&#125;) &#125;"&gt;查看博客&lt;/a&gt;--&gt; &lt;a href="#" th:href="@&#123; http://www.panyutao.top &#125;"&gt;查看博客&lt;/a&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot日志管理]]></title>
    <url>%2F2017%2F12%2F25%2Flogback%2F</url>
    <content type="text"><![CDATA[简单学习 SLF4J+LogbackSLF4J简介 slf4j的全称是Simple Loging Facade For Java，即它仅仅是一个为Java程序提供日志输出的统一接口，并不是一个具体的日志实现方案，就比如JDBC一样，只是一种规则而已。所以单独的slf4j是不能工作的，必须搭配其他具体的日志实现方案。slf4j只是一种接口，它本身并不关心你底层使用的是什么日志实现方案，所以它支持各种日志实现方案。简单的说，只要我们在类库中使用slf4j打日志，那么底层使用什么日志实现方案是使用者决定的，怎么决定？依靠配置文件和jar库。 SLF4J优势使用SLF4J的而不是直接使用 Log4j, commons logging, logback 或者 java.util.logging 1.在你的开源或内部类库中使用SLF4J会使得它独立于任何一个特定的日志实现，这意味着不需要管理多个日志配置或者多个日志类库，你的客户端会很感激这点。2.SLF4J提供了基于占位符的日志方法，这通过去除检查isDebugEnabled(), isInfoEnabled()等等，提高了代码可读性。3.通过使用SLF4J的日志方法，你可以延迟构建日志信息（Srting）的开销，直到你真正需要，这对于内存和CPU都是高效的。4.作为附注，更少的暂时的字符串意味着垃圾回收器（Garbage Collector）需要做更好的工作，这意味着你的应用程序有为更好的吞吐量和性能。 SLF4J+Logback配置pom.xml 配置123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; 新建 logback.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒当scan为true时，此属性生效。默认的时间间隔为1分钟。debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。--&gt;&lt;configuration scan="false" scanPeriod="60 seconds" debug="false"&gt; &lt;!-- 定义日志的根目录 --&gt; &lt;property name="LOG_HOME" value="F:\\javaPhotoTest\\log" /&gt; &lt;!-- 定义日志文件名称 --&gt; &lt;property name="appName" value="pan"&gt;&lt;/property&gt; &lt;!-- ch.qos.logback.core.ConsoleAppender 表示控制台输出 --&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 日志输出格式：%d表示日期时间，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息，%n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt; &lt;appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 指定日志文件的名称 --&gt; &lt;file&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;.log&lt;/file&gt; &lt;!-- 当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名 TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 滚动时产生的文件的存放位置及文件名称 %d&#123;yyyy-MM-dd&#125;：按天进行日志滚动 %i：当文件大小超过maxFileSize时，按照i进行文件滚动 --&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log&lt;/fileNamePattern&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每天滚动， 且maxHistory是365，则只保存最近365天的文件，删除之前的旧文件。注意，删除旧文件是， 那些为了归档而创建的目录也会被删除。 --&gt; &lt;MaxHistory&gt;365&lt;/MaxHistory&gt; &lt;!-- 当日志文件超过maxFileSize指定的大小是，根据上面提到的%i进行日志文件滚动 注意此处配置SizeBasedTriggeringPolicy是无法实现按文件大小进行滚动的，必须配置timeBasedFileNamingAndTriggeringPolicy --&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;!-- 日志输出格式：%d表示日期时间，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息，%n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [ %thread ] - [ %-5level ] [ %logger&#123;50&#125; : %line ] - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- logger主要用于存放日志对象，也可以定义日志类型、级别 name：表示匹配的logger类型前缀，也就是包的前半部分 level：要记录的日志级别，包括 TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR additivity：作用在于children-logger是否使用 rootLogger配置的appender进行输出，false：表示只用当前logger的appender-ref，true：表示当前logger的appender-ref和rootLogger的appender-ref都有效 --&gt; &lt;!-- hibernate logger --&gt; &lt;!--&lt;logger name="org.hibernate" level="error" /&gt;--&gt; &lt;!-- Spring framework logger --&gt; &lt;logger name="org.springframework" level="error" additivity="false"&gt;&lt;/logger&gt; &lt;logger name="com.smile.dao" level="trace"&gt; &lt;appender-ref ref="file" /&gt; &lt;/logger&gt; &lt;!-- root与logger是父子关系，没有特别定义则默认为root，任何一个类只会和一个logger对应， 要么是定义的logger，要么是root，判断的关键在于找到这个logger，然后判断这个logger的appender和level。 --&gt; &lt;root level="info"&gt; &lt;appender-ref ref="console" /&gt; &lt;appender-ref ref="file" /&gt; &lt;/root&gt;&lt;/configuration&gt; 备注关于&lt;Encoding&gt;UTF-8&lt;/Encoding&gt; 1.设置Encoding。在appender中增加一行UTF-8，但是在启动中报错，说是不能识别Encoding元素。有人说Encoding在0.9.22以后版本中已经不能用了。2.设置charset, 在encoder 中增加一行 UTF-8，重新启动系统，日志中中文显示正常了。 附加Why do we declare Loggers static final?为什么要将日志记录定义为static以及final？ private - so that no other class can hijack your logger static - so there is only one logger instance per class, also avoiding attempts to serialize loggers final - no need to change the logger over the lifetime of the class]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 拦截器]]></title>
    <url>%2F2017%2F12%2F25%2Finterceptor%2F</url>
    <content type="text"><![CDATA[概述 Web开发中，我们除了使用 Filter 来过滤web请求外，还可以使用Spring提供的HandlerInterceptor（拦截器）。HandlerInterceptor 的功能跟过滤器类似，但是提供更精细的的控制能力：在request被响应之前、request被响应之后、视图渲染之前以及request全部结束之后。我们不能通过拦截器修改request内容，但是可以通过抛出异常（或者返回false）来暂停request的执行。 实现自定义拦截器三步走： 1.创建我们自己的拦截器类并实现 HandlerInterceptor 接口。 2.创建一个Java类继承WebMvcConfigurerAdapter，并重写 addInterceptors 方法。 3.实例化我们自定义的拦截器，然后将对像手动添加到拦截器链中（在addInterceptors方法中添加）。 样例登录状态拦截器12345678910111213141516171819202122232425262728293031323334public class SessionInterceptor implements HandlerInterceptor&#123; //在请求处理之前进行调用（Controller方法调用之前） @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object o) throws Exception &#123; System.out.println(request.getRequestURI()); //登录不做拦截 if(request.getRequestURI().equals("/user/login") || request.getRequestURI().equals("/user/login_view")) &#123; return true; &#125; //验证session是否存在 Object obj = request.getSession().getAttribute("_session_user"); if(obj == null) &#123; response.sendRedirect("/user/login_view"); return false; &#125; return true; &#125; //请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后） @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; &#125; //在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行（主要是用于进行资源清理工作） @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; &#125;&#125; 12345678@Configurationpublic class MyInterceptorConfig extends WebMvcConfigurerAdapter&#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new SessionInterceptor()).addPathPatterns("/**"); &#125;&#125; 处理时间拦截器123456789101112131415161718192021222324public class ChanelInterceptor implements HandlerInterceptor &#123; private static Logger logger = LoggerFactory.getLogger(ChanelInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object o) throws Exception &#123; logger.info("============================拦截器启动=============================="); request.setAttribute("starttime",System.currentTimeMillis()); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object o, ModelAndView modelAndView) throws Exception &#123; logger.info("===========================执行处理完毕============================="); long starttime = (long) request.getAttribute("starttime"); request.removeAttribute("starttime"); long endtime = System.currentTimeMillis(); logger.info("============请求地址："+request.getRequestURI()+"：处理时间：&#123;&#125;",(endtime-starttime)+"ms"); &#125; @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; logger.info("============================拦截器关闭=============================="); &#125;&#125; 1234567@Configurationpublic class MyInterceptorConfig extends WebMvcConfigurerAdapter&#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new ChanelInterceptor()).addPathPatterns("/**"); &#125;&#125;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis-generator]]></title>
    <url>%2F2017%2F12%2F25%2Fmappergenerator%2F</url>
    <content type="text"><![CDATA[Intellij IDEA 使用MyBatis-generator 自动生成MyBatis代码 步骤1在maven项目的pom.xml 添加mybatis-generator-maven-plugin 插件，如图： 123456789&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt;&lt;/plugin&gt; 步骤2 在maven项目下的src/main/resources 目录下建立名为 generatorConfig.xml的配置文件，作为mybatis-generator-maven-plugin 插件的执行目标 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- 数据库驱动包位置 --&gt; &lt;classPathEntry location="D:\mysql-5.7.19-winx64\mysql-connector-java-5.1.35.jar" /&gt; &lt;context id="MysqlTables" targetRuntime="MyBatis3"&gt; &lt;!--是否去除自动生成的注释 是：true 否：false--&gt; &lt;commentGenerator&gt; &lt;property name="suppressAllComments" value="true" /&gt; &lt;/commentGenerator&gt; &lt;!-- 数据库驱动类、链接URL、用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://120.79.6.242:3306/mytest?characterEncoding=utf8" userId="root" password="Swust306"&gt; &lt;!--&lt;jdbcConnection driverClass="oracle.jdbc.driver.OracleDriver" connectionURL="jdbc:oracle:thin:@localhost:1521:orcl" userId="msa" password="msa"&gt;--&gt; &lt;/jdbcConnection&gt; &lt;!--非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成模型的包名和位置 --&gt; &lt;javaModelGenerator targetPackage="com.smile.domain" targetProject="src\main\java"&gt; &lt;!--是否让schema作为包的后缀--&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;!--从数据库返回的值被清理前后的空格--&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成的映射文件包名和位置 --&gt; &lt;sqlMapGenerator targetPackage="com.smile.dao" targetProject="src\main\java"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.smile.dao" targetProject="src\main\java"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成那些表(更改tableName和domainObjectName就可以) --&gt; &lt;table schema="" tableName="article_info" domainObjectName="ArticleInfo"/&gt; &lt;!--&lt;table tableName="user_info" domainObjectName="UserInfo" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false" /&gt;--&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 步骤3 在Intellij IDEA添加一个“Run运行”选项，使用maven运行mybatis-generator-maven-plugin插件，如图：]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JXL操作Excel模板]]></title>
    <url>%2F2017%2F12%2F24%2Fjxl20171223%2F</url>
    <content type="text"><![CDATA[JXL操作Excel简单总结一下使用JXL来对Excel模板进行添加数据 最近遇到个需要，要对表头较为复杂的Excel进行数据的填充，考虑到表头的复杂性，没有选择一步步去合并单元格等操作来生成表头，故采用直接复制模板，然后对相应单元格进行操作，以此文章贴出代码来对其进行简单总结。 基础参考12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import com.excel.jxl.model.User;import jxl.Workbook;import jxl.read.biff.BiffException;import jxl.write.Boolean;import jxl.write.*;import jxl.write.Number;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.math.BigDecimal;import java.text.SimpleDateFormat;import java.util.Date;/** * Created by pyt on 2017/12/24/0022. */public class JxlReadExport &#123; private static final int MAX_ROWS = 100; public static void main(String[] args) throws IOException, BiffException &#123; // 表格要导出的目录 String outPath = "C:\\Users\\susq\\Desktop\\sheet.xls"; FileOutputStream is = new FileOutputStream(outPath); // 模板文件路径 String templePath = "C:\\Users\\susq\\Desktop\\模板.xls"; // 读取模板文件 Workbook wb = Workbook.getWorkbook(new File(templePath)); // 根据模板文件创建可写的文件，注意这里是createWorkbook(),创建而不是获取 WritableWorkbook wwb = Workbook.createWorkbook(is, wb); // 注意这里是getSheet(), 通过索引，获取模板文件中的sheet页第一页 WritableSheet sheet = wwb.getSheet(0); for(int i=1; i&lt;=MAX_ROWS; i++) &#123; // 从第二行开始插入，第一行表头 User user = new User((long) i, "张三", "14", true, new Date(), new BigDecimal("111112345.6789")); // 第一个参数指定单元格的列数、第二个参数指定单元格的行数，第三个指定写的字符串内容 // 填充数字， import jxl.write.Number; Number label1 = new Number(0, i, user.getId()); // 填充文本 Label label2 = new Label(1, i, user.getName()); Label label3 = new Label(2, i, user.getAge()); // 填充布尔值， import jxl.write.Boolean; Boolean label4 = new Boolean(3, i, user.getSex()); // 填充日期 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); String date = sdf.format(user.getCreateTime()); Label label5 = new Label(4, i, date); // 填充格式化的数字, 保留6位小数，不足六位的时候有几位保留几位。非小数部分用千位符隔开 jxl.write.NumberFormat nf = new jxl.write.NumberFormat("###,###,###.######"); jxl.write.WritableCellFormat wcf = new jxl.write.WritableCellFormat(nf); jxl.write.Number label6 = new jxl.write.Number(5, i, user.getSalary().doubleValue(), wcf); try &#123; sheet.addCell(label1); sheet.addCell(label2); sheet.addCell(label3); sheet.addCell(label4); sheet.addCell(label5); sheet.addCell(label6); &#125; catch (WriteException e) &#123; e.printStackTrace(); &#125; &#125; try &#123; wwb.write(); wwb.close(); is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (WriteException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 根据模板，生成对应的Excel，并填充数据(文本)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import jxl.CellView;import jxl.Workbook;import jxl.WorkbookSettings;import jxl.format.ScriptStyle;import jxl.format.UnderlineStyle;import jxl.read.biff.BiffException;import jxl.write.Boolean;import jxl.write.*;import jxl.write.Number;import jxl.write.biff.RowsExceededException;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.math.BigDecimal;import java.text.SimpleDateFormat;import java.util.Date;public class Test &#123; private static final int MAX_ROWS = 7; public static void main(String[] args) throws IOException, BiffException &#123; // TODO Auto-generated method stub // 表格要导出的目录 String outPath = "C:\\Users\\swust306xu\\Desktop\\sheet.xls"; FileOutputStream is = new FileOutputStream(outPath); // 模板文件路径 String templePath = "C:\\Users\\swust306xu\\Desktop\\业务发展指标.xls"; // 读取模板文件 Workbook wb = Workbook.getWorkbook(new File(templePath)); WorkbookSettings wbSettings = new WorkbookSettings (); wbSettings.setWriteAccess(null); // 根据模板文件创建可写的文件，注意这里是createWorkbook(),创建而不是获取 WritableWorkbook wwb = Workbook.createWorkbook(is, wb , wbSettings); // 注意这里是getSheet(), 通过索引，获取模板文件中的sheet页第一页 WritableSheet sheet = wwb.getSheet(0); WritableFont titleWf = new WritableFont(WritableFont.createFont("宋体"),// 字体 12,//WritableFont.DEFAULT_POINT_SIZE, // 字号 WritableFont.NO_BOLD, // 粗体 false, // 斜体 UnderlineStyle.NO_UNDERLINE, // 下划线 Colour.BLACK, // 字体颜色 ScriptStyle.NORMAL_SCRIPT); WritableCellFormat cFormat = new WritableCellFormat(titleWf); try &#123; cFormat.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,jxl.format.Colour.BLACK); &#125; catch (WriteException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; CellView cellView = new CellView(); cellView.setAutosize(true); //设置自动大小 Label lab = null; for(int i=5; i&lt;=MAX_ROWS; i++) &#123; // 从第二行开始插入，第一行表头 for(int j=0;j&lt;22;j++) &#123; sheet.setColumnView(i, cellView);//根据内容自动设置列宽 lab = new Label(j,i,"测试方法",cFormat); //Label(col,row,str); try &#123; sheet.addCell(lab); &#125; catch (RowsExceededException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (WriteException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; try &#123; wwb.write(); wwb.close(); is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (WriteException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>jxl</category>
      </categories>
      <tags>
        <tag>jxl</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令]]></title>
    <url>%2F2017%2F12%2F11%2Fhexocommon%2F</url>
    <content type="text"><![CDATA[Hexo命令总结常用命令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 复合命令12hexo deploy -g #生成加部署hexo server -g #生成加预览 命令简写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 部署步骤每次部署都可以按照下面的步骤，或者用上面的复合命令123hexo cleanhexo generatehexo deploy 本地测试12hexo g #生成hexo s #启动本地服务，进行文章预览调试 浏览器输入 http://localhost:4000 ，查看搭建效果。此后的每次变更_config.yml 文件或者新建文件都可以先用此命令调试，尤其是当你想调试新添加的主题时。可以用一条简化的命令 1hexo s -g 文章头部格式12345678---title: hexocommondate: 2017-12-11 21:23:17tags: - hexocategories: - hexo--- 基本配置参考文章：http://www.shenzekun.cn/hexo的next主题个性化配置教程.html]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post和Get的区别]]></title>
    <url>%2F2017%2F12%2F11%2Fpostget%2F</url>
    <content type="text"><![CDATA[什么是 HTTP？ 超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。 HTTP 的工作方式是客户机与服务器之间的请求-应答协议。 web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。 举例：客户端（浏览器）向服务器提交HTTP请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。GET请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：/test/demo_form.asp?name1=value1&amp;name2=value2 GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 POST 请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的： POST /test/demo_form.asp HTTP/1.1 Host: w3schools.com name1=value1&amp;name2=value2 POST 请求不会被缓存 POST 请求不会保留在浏览器历史记录中 POST 不能被收藏为书签 GET POST 请求对数据长度没有要求 … GET POST 后退按钮/刷新 可收藏为书签 不可收藏为书签 书签 能被缓存 不能缓存 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中 参数不会保存在浏览器历史中 对数据长度的限制 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 无限制。 对数据类型的限制 只允许 ASCII 字符。 没有限制。也允许二进制数据。 安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是URL的一部分。在发送密码或其他敏感信息时绝不要使用 GET POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 可见性 数据在 URL 中对所有人都是可见的。 数据不会显示在 URL 中。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>post</tag>
        <tag>get</tag>
      </tags>
  </entry>
</search>
