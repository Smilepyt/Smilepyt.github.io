<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MyBatis-generator]]></title>
    <url>%2F2017%2F12%2F25%2Fmappergenerator%2F</url>
    <content type="text"><![CDATA[Intellij IDEA 使用MyBatis-generator 自动生成MyBatis代码 步骤1在maven项目的pom.xml 添加mybatis-generator-maven-plugin 插件，如图： 123456789&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt;&lt;/plugin&gt; 步骤2 在maven项目下的src/main/resources 目录下建立名为 generatorConfig.xml的配置文件，作为mybatis-generator-maven-plugin 插件的执行目标 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- 数据库驱动包位置 --&gt; &lt;classPathEntry location="D:\mysql-5.7.19-winx64\mysql-connector-java-5.1.35.jar" /&gt; &lt;context id="MysqlTables" targetRuntime="MyBatis3"&gt; &lt;!--是否去除自动生成的注释 是：true 否：false--&gt; &lt;commentGenerator&gt; &lt;property name="suppressAllComments" value="true" /&gt; &lt;/commentGenerator&gt; &lt;!-- 数据库驱动类、链接URL、用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://120.79.6.242:3306/mytest?characterEncoding=utf8" userId="root" password="Swust306"&gt; &lt;!--&lt;jdbcConnection driverClass="oracle.jdbc.driver.OracleDriver" connectionURL="jdbc:oracle:thin:@localhost:1521:orcl" userId="msa" password="msa"&gt;--&gt; &lt;/jdbcConnection&gt; &lt;!--非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成模型的包名和位置 --&gt; &lt;javaModelGenerator targetPackage="com.smile.domain" targetProject="src\main\java"&gt; &lt;!--是否让schema作为包的后缀--&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;!--从数据库返回的值被清理前后的空格--&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成的映射文件包名和位置 --&gt; &lt;sqlMapGenerator targetPackage="com.smile.dao" targetProject="src\main\java"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.smile.dao" targetProject="src\main\java"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成那些表(更改tableName和domainObjectName就可以) --&gt; &lt;table schema="" tableName="article_info" domainObjectName="ArticleInfo"/&gt; &lt;!--&lt;table tableName="user_info" domainObjectName="UserInfo" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false" /&gt;--&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 步骤3 在Intellij IDEA添加一个“Run运行”选项，使用maven运行mybatis-generator-maven-plugin插件，如图：]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JXL操作Excel模板]]></title>
    <url>%2F2017%2F12%2F24%2Fjxl20171223%2F</url>
    <content type="text"><![CDATA[JXL操作Excel简单总结一下使用JXL来对Excel模板进行添加数据 最近遇到个需要，要对表头较为复杂的Excel进行数据的填充，考虑到表头的复杂性，没有选择一步步去合并单元格等操作来生成表头，故采用直接复制模板，然后对相应单元格进行操作，以此文章贴出代码来对其进行简单总结。 基础参考12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import com.excel.jxl.model.User;import jxl.Workbook;import jxl.read.biff.BiffException;import jxl.write.Boolean;import jxl.write.*;import jxl.write.Number;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.math.BigDecimal;import java.text.SimpleDateFormat;import java.util.Date;/** * Created by pyt on 2017/12/24/0022. */public class JxlReadExport &#123; private static final int MAX_ROWS = 100; public static void main(String[] args) throws IOException, BiffException &#123; // 表格要导出的目录 String outPath = "C:\\Users\\susq\\Desktop\\sheet.xls"; FileOutputStream is = new FileOutputStream(outPath); // 模板文件路径 String templePath = "C:\\Users\\susq\\Desktop\\模板.xls"; // 读取模板文件 Workbook wb = Workbook.getWorkbook(new File(templePath)); // 根据模板文件创建可写的文件，注意这里是createWorkbook(),创建而不是获取 WritableWorkbook wwb = Workbook.createWorkbook(is, wb); // 注意这里是getSheet(), 通过索引，获取模板文件中的sheet页第一页 WritableSheet sheet = wwb.getSheet(0); for(int i=1; i&lt;=MAX_ROWS; i++) &#123; // 从第二行开始插入，第一行表头 User user = new User((long) i, "张三", "14", true, new Date(), new BigDecimal("111112345.6789")); // 第一个参数指定单元格的列数、第二个参数指定单元格的行数，第三个指定写的字符串内容 // 填充数字， import jxl.write.Number; Number label1 = new Number(0, i, user.getId()); // 填充文本 Label label2 = new Label(1, i, user.getName()); Label label3 = new Label(2, i, user.getAge()); // 填充布尔值， import jxl.write.Boolean; Boolean label4 = new Boolean(3, i, user.getSex()); // 填充日期 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); String date = sdf.format(user.getCreateTime()); Label label5 = new Label(4, i, date); // 填充格式化的数字, 保留6位小数，不足六位的时候有几位保留几位。非小数部分用千位符隔开 jxl.write.NumberFormat nf = new jxl.write.NumberFormat("###,###,###.######"); jxl.write.WritableCellFormat wcf = new jxl.write.WritableCellFormat(nf); jxl.write.Number label6 = new jxl.write.Number(5, i, user.getSalary().doubleValue(), wcf); try &#123; sheet.addCell(label1); sheet.addCell(label2); sheet.addCell(label3); sheet.addCell(label4); sheet.addCell(label5); sheet.addCell(label6); &#125; catch (WriteException e) &#123; e.printStackTrace(); &#125; &#125; try &#123; wwb.write(); wwb.close(); is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (WriteException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 根据模板，生成对应的Excel，并填充数据(文本)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import jxl.CellView;import jxl.Workbook;import jxl.WorkbookSettings;import jxl.format.ScriptStyle;import jxl.format.UnderlineStyle;import jxl.read.biff.BiffException;import jxl.write.Boolean;import jxl.write.*;import jxl.write.Number;import jxl.write.biff.RowsExceededException;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.math.BigDecimal;import java.text.SimpleDateFormat;import java.util.Date;public class Test &#123; private static final int MAX_ROWS = 7; public static void main(String[] args) throws IOException, BiffException &#123; // TODO Auto-generated method stub // 表格要导出的目录 String outPath = "C:\\Users\\swust306xu\\Desktop\\sheet.xls"; FileOutputStream is = new FileOutputStream(outPath); // 模板文件路径 String templePath = "C:\\Users\\swust306xu\\Desktop\\业务发展指标.xls"; // 读取模板文件 Workbook wb = Workbook.getWorkbook(new File(templePath)); WorkbookSettings wbSettings = new WorkbookSettings (); wbSettings.setWriteAccess(null); // 根据模板文件创建可写的文件，注意这里是createWorkbook(),创建而不是获取 WritableWorkbook wwb = Workbook.createWorkbook(is, wb , wbSettings); // 注意这里是getSheet(), 通过索引，获取模板文件中的sheet页第一页 WritableSheet sheet = wwb.getSheet(0); WritableFont titleWf = new WritableFont(WritableFont.createFont("宋体"),// 字体 12,//WritableFont.DEFAULT_POINT_SIZE, // 字号 WritableFont.NO_BOLD, // 粗体 false, // 斜体 UnderlineStyle.NO_UNDERLINE, // 下划线 Colour.BLACK, // 字体颜色 ScriptStyle.NORMAL_SCRIPT); WritableCellFormat cFormat = new WritableCellFormat(titleWf); try &#123; cFormat.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,jxl.format.Colour.BLACK); &#125; catch (WriteException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; CellView cellView = new CellView(); cellView.setAutosize(true); //设置自动大小 Label lab = null; for(int i=5; i&lt;=MAX_ROWS; i++) &#123; // 从第二行开始插入，第一行表头 for(int j=0;j&lt;22;j++) &#123; sheet.setColumnView(i, cellView);//根据内容自动设置列宽 lab = new Label(j,i,"测试方法",cFormat); //Label(col,row,str); try &#123; sheet.addCell(lab); &#125; catch (RowsExceededException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (WriteException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; try &#123; wwb.write(); wwb.close(); is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (WriteException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>jxl</category>
      </categories>
      <tags>
        <tag>jxl</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令]]></title>
    <url>%2F2017%2F12%2F11%2Fhexocommon%2F</url>
    <content type="text"><![CDATA[Hexo命令总结常用命令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 复合命令12hexo deploy -g #生成加部署hexo server -g #生成加预览 命令简写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 部署步骤每次部署都可以按照下面的步骤，或者用上面的复合命令123hexo cleanhexo generatehexo deploy 本地测试12hexo g #生成hexo s #启动本地服务，进行文章预览调试 浏览器输入 http://localhost:4000 ，查看搭建效果。此后的每次变更_config.yml 文件或者新建文件都可以先用此命令调试，尤其是当你想调试新添加的主题时。可以用一条简化的命令 1hexo s -g 文章头部格式12345678---title: hexocommondate: 2017-12-11 21:23:17tags: - hexocategories: - hexo--- 基本配置参考文章：http://www.shenzekun.cn/hexo的next主题个性化配置教程.html]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post和Get的区别]]></title>
    <url>%2F2017%2F12%2F11%2Fpostget%2F</url>
    <content type="text"><![CDATA[什么是 HTTP？ 超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。 HTTP 的工作方式是客户机与服务器之间的请求-应答协议。 web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。 举例：客户端（浏览器）向服务器提交HTTP请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。GET请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：/test/demo_form.asp?name1=value1&amp;name2=value2 GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 POST 请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的： POST /test/demo_form.asp HTTP/1.1 Host: w3schools.com name1=value1&amp;name2=value2 POST 请求不会被缓存 POST 请求不会保留在浏览器历史记录中 POST 不能被收藏为书签 GET POST 请求对数据长度没有要求 … GET POST 后退按钮/刷新 可收藏为书签 不可收藏为书签 书签 能被缓存 不能缓存 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中 参数不会保存在浏览器历史中 对数据长度的限制 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 无限制。 对数据类型的限制 只允许 ASCII 字符。 没有限制。也允许二进制数据。 安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是URL的一部分。在发送密码或其他敏感信息时绝不要使用 GET POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 可见性 数据在 URL 中对所有人都是可见的。 数据不会显示在 URL 中。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>post</tag>
        <tag>get</tag>
      </tags>
  </entry>
</search>
