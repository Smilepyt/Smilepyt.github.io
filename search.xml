<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Boot日志管理]]></title>
    <url>%2F2017%2F12%2F25%2Flogback%2F</url>
    <content type="text"><![CDATA[简单学习 SLF4J+LogbackSLF4J简介 slf4j的全称是Simple Loging Facade For Java，即它仅仅是一个为Java程序提供日志输出的统一接口，并不是一个具体的日志实现方案，就比如JDBC一样，只是一种规则而已。所以单独的slf4j是不能工作的，必须搭配其他具体的日志实现方案。slf4j只是一种接口，它本身并不关心你底层使用的是什么日志实现方案，所以它支持各种日志实现方案。简单的说，只要我们在类库中使用slf4j打日志，那么底层使用什么日志实现方案是使用者决定的，怎么决定？依靠配置文件和jar库。 SLF4J优势使用SLF4J的而不是直接使用 Log4j, commons logging, logback 或者 java.util.logging 1.在你的开源或内部类库中使用SLF4J会使得它独立于任何一个特定的日志实现，这意味着不需要管理多个日志配置或者多个日志类库，你的客户端会很感激这点。2.SLF4J提供了基于占位符的日志方法，这通过去除检查isDebugEnabled(), isInfoEnabled()等等，提高了代码可读性。3.通过使用SLF4J的日志方法，你可以延迟构建日志信息（Srting）的开销，直到你真正需要，这对于内存和CPU都是高效的。4.作为附注，更少的暂时的字符串意味着垃圾回收器（Garbage Collector）需要做更好的工作，这意味着你的应用程序有为更好的吞吐量和性能。 SLF4J+Logback配置pom.xml 配置123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt;&lt;/dependency&gt; 新建 logback.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒当scan为true时，此属性生效。默认的时间间隔为1分钟。debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。--&gt;&lt;configuration scan="false" scanPeriod="60 seconds" debug="false"&gt; &lt;!-- 定义日志的根目录 --&gt; &lt;property name="LOG_HOME" value="F:\\javaPhotoTest\\log" /&gt; &lt;!-- 定义日志文件名称 --&gt; &lt;property name="appName" value="pan"&gt;&lt;/property&gt; &lt;!-- ch.qos.logback.core.ConsoleAppender 表示控制台输出 --&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;!-- 日志输出格式：%d表示日期时间，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息，%n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt; &lt;appender name="file" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!-- 指定日志文件的名称 --&gt; &lt;file&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;.log&lt;/file&gt; &lt;!-- 当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名 TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 滚动时产生的文件的存放位置及文件名称 %d&#123;yyyy-MM-dd&#125;：按天进行日志滚动 %i：当文件大小超过maxFileSize时，按照i进行文件滚动 --&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/$&#123;appName&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log&lt;/fileNamePattern&gt; &lt;!-- 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每天滚动， 且maxHistory是365，则只保存最近365天的文件，删除之前的旧文件。注意，删除旧文件是， 那些为了归档而创建的目录也会被删除。 --&gt; &lt;MaxHistory&gt;365&lt;/MaxHistory&gt; &lt;!-- 当日志文件超过maxFileSize指定的大小是，根据上面提到的%i进行日志文件滚动 注意此处配置SizeBasedTriggeringPolicy是无法实现按文件大小进行滚动的，必须配置timeBasedFileNamingAndTriggeringPolicy --&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;!-- 日志输出格式：%d表示日期时间，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 %msg：日志消息，%n是换行符 --&gt; &lt;layout class="ch.qos.logback.classic.PatternLayout"&gt; &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [ %thread ] - [ %-5level ] [ %logger&#123;50&#125; : %line ] - %msg%n&lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- logger主要用于存放日志对象，也可以定义日志类型、级别 name：表示匹配的logger类型前缀，也就是包的前半部分 level：要记录的日志级别，包括 TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR additivity：作用在于children-logger是否使用 rootLogger配置的appender进行输出，false：表示只用当前logger的appender-ref，true：表示当前logger的appender-ref和rootLogger的appender-ref都有效 --&gt; &lt;!-- hibernate logger --&gt; &lt;!--&lt;logger name="org.hibernate" level="error" /&gt;--&gt; &lt;!-- Spring framework logger --&gt; &lt;logger name="org.springframework" level="error" additivity="false"&gt;&lt;/logger&gt; &lt;logger name="com.smile.dao" level="trace"&gt; &lt;appender-ref ref="file" /&gt; &lt;/logger&gt; &lt;!-- root与logger是父子关系，没有特别定义则默认为root，任何一个类只会和一个logger对应， 要么是定义的logger，要么是root，判断的关键在于找到这个logger，然后判断这个logger的appender和level。 --&gt; &lt;root level="info"&gt; &lt;appender-ref ref="console" /&gt; &lt;appender-ref ref="file" /&gt; &lt;/root&gt;&lt;/configuration&gt; 备注关于&lt;Encoding&gt;UTF-8&lt;/Encoding&gt; 1.设置Encoding。在appender中增加一行UTF-8，但是在启动中报错，说是不能识别Encoding元素。有人说Encoding在0.9.22以后版本中已经不能用了。2.设置charset, 在encoder 中增加一行 UTF-8，重新启动系统，日志中中文显示正常了。 附加Why do we declare Loggers static final?为什么要将日志记录定义为static以及final？ private - so that no other class can hijack your logger static - so there is only one logger instance per class, also avoiding attempts to serialize loggers final - no need to change the logger over the lifetime of the class]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring 拦截器]]></title>
    <url>%2F2017%2F12%2F25%2Finterceptor%2F</url>
    <content type="text"><![CDATA[概述 Web开发中，我们除了使用 Filter 来过滤web请求外，还可以使用Spring提供的HandlerInterceptor（拦截器）。HandlerInterceptor 的功能跟过滤器类似，但是提供更精细的的控制能力：在request被响应之前、request被响应之后、视图渲染之前以及request全部结束之后。我们不能通过拦截器修改request内容，但是可以通过抛出异常（或者返回false）来暂停request的执行。 实现自定义拦截器三步走： 1.创建我们自己的拦截器类并实现 HandlerInterceptor 接口。 2.创建一个Java类继承WebMvcConfigurerAdapter，并重写 addInterceptors 方法。 3.实例化我们自定义的拦截器，然后将对像手动添加到拦截器链中（在addInterceptors方法中添加）。 样例登录状态拦截器12345678910111213141516171819202122232425262728293031323334public class SessionInterceptor implements HandlerInterceptor&#123; //在请求处理之前进行调用（Controller方法调用之前） @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object o) throws Exception &#123; System.out.println(request.getRequestURI()); //登录不做拦截 if(request.getRequestURI().equals("/user/login") || request.getRequestURI().equals("/user/login_view")) &#123; return true; &#125; //验证session是否存在 Object obj = request.getSession().getAttribute("_session_user"); if(obj == null) &#123; response.sendRedirect("/user/login_view"); return false; &#125; return true; &#125; //请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后） @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; &#125; //在整个请求结束之后被调用，也就是在DispatcherServlet 渲染了对应的视图之后执行（主要是用于进行资源清理工作） @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; &#125;&#125; 12345678@Configurationpublic class MyInterceptorConfig extends WebMvcConfigurerAdapter&#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new SessionInterceptor()).addPathPatterns("/**"); &#125;&#125; 处理时间拦截器123456789101112131415161718192021222324public class ChanelInterceptor implements HandlerInterceptor &#123; private static Logger logger = LoggerFactory.getLogger(ChanelInterceptor.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object o) throws Exception &#123; logger.info("============================拦截器启动=============================="); request.setAttribute("starttime",System.currentTimeMillis()); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object o, ModelAndView modelAndView) throws Exception &#123; logger.info("===========================执行处理完毕============================="); long starttime = (long) request.getAttribute("starttime"); request.removeAttribute("starttime"); long endtime = System.currentTimeMillis(); logger.info("============请求地址："+request.getRequestURI()+"：处理时间：&#123;&#125;",(endtime-starttime)+"ms"); &#125; @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; logger.info("============================拦截器关闭=============================="); &#125;&#125; 1234567@Configurationpublic class MyInterceptorConfig extends WebMvcConfigurerAdapter&#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new ChanelInterceptor()).addPathPatterns("/**"); &#125;&#125;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis-generator]]></title>
    <url>%2F2017%2F12%2F25%2Fmappergenerator%2F</url>
    <content type="text"><![CDATA[Intellij IDEA 使用MyBatis-generator 自动生成MyBatis代码 步骤1在maven项目的pom.xml 添加mybatis-generator-maven-plugin 插件，如图： 123456789&lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt;&lt;/plugin&gt; 步骤2 在maven项目下的src/main/resources 目录下建立名为 generatorConfig.xml的配置文件，作为mybatis-generator-maven-plugin 插件的执行目标 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- 数据库驱动包位置 --&gt; &lt;classPathEntry location="D:\mysql-5.7.19-winx64\mysql-connector-java-5.1.35.jar" /&gt; &lt;context id="MysqlTables" targetRuntime="MyBatis3"&gt; &lt;!--是否去除自动生成的注释 是：true 否：false--&gt; &lt;commentGenerator&gt; &lt;property name="suppressAllComments" value="true" /&gt; &lt;/commentGenerator&gt; &lt;!-- 数据库驱动类、链接URL、用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://120.79.6.242:3306/mytest?characterEncoding=utf8" userId="root" password="Swust306"&gt; &lt;!--&lt;jdbcConnection driverClass="oracle.jdbc.driver.OracleDriver" connectionURL="jdbc:oracle:thin:@localhost:1521:orcl" userId="msa" password="msa"&gt;--&gt; &lt;/jdbcConnection&gt; &lt;!--非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false" /&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成模型的包名和位置 --&gt; &lt;javaModelGenerator targetPackage="com.smile.domain" targetProject="src\main\java"&gt; &lt;!--是否让schema作为包的后缀--&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;!--从数据库返回的值被清理前后的空格--&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成的映射文件包名和位置 --&gt; &lt;sqlMapGenerator targetPackage="com.smile.dao" targetProject="src\main\java"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.smile.dao" targetProject="src\main\java"&gt; &lt;property name="enableSubPackages" value="true" /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成那些表(更改tableName和domainObjectName就可以) --&gt; &lt;table schema="" tableName="article_info" domainObjectName="ArticleInfo"/&gt; &lt;!--&lt;table tableName="user_info" domainObjectName="UserInfo" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false" /&gt;--&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 步骤3 在Intellij IDEA添加一个“Run运行”选项，使用maven运行mybatis-generator-maven-plugin插件，如图：]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JXL操作Excel模板]]></title>
    <url>%2F2017%2F12%2F24%2Fjxl20171223%2F</url>
    <content type="text"><![CDATA[JXL操作Excel简单总结一下使用JXL来对Excel模板进行添加数据 最近遇到个需要，要对表头较为复杂的Excel进行数据的填充，考虑到表头的复杂性，没有选择一步步去合并单元格等操作来生成表头，故采用直接复制模板，然后对相应单元格进行操作，以此文章贴出代码来对其进行简单总结。 基础参考12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import com.excel.jxl.model.User;import jxl.Workbook;import jxl.read.biff.BiffException;import jxl.write.Boolean;import jxl.write.*;import jxl.write.Number;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.math.BigDecimal;import java.text.SimpleDateFormat;import java.util.Date;/** * Created by pyt on 2017/12/24/0022. */public class JxlReadExport &#123; private static final int MAX_ROWS = 100; public static void main(String[] args) throws IOException, BiffException &#123; // 表格要导出的目录 String outPath = "C:\\Users\\susq\\Desktop\\sheet.xls"; FileOutputStream is = new FileOutputStream(outPath); // 模板文件路径 String templePath = "C:\\Users\\susq\\Desktop\\模板.xls"; // 读取模板文件 Workbook wb = Workbook.getWorkbook(new File(templePath)); // 根据模板文件创建可写的文件，注意这里是createWorkbook(),创建而不是获取 WritableWorkbook wwb = Workbook.createWorkbook(is, wb); // 注意这里是getSheet(), 通过索引，获取模板文件中的sheet页第一页 WritableSheet sheet = wwb.getSheet(0); for(int i=1; i&lt;=MAX_ROWS; i++) &#123; // 从第二行开始插入，第一行表头 User user = new User((long) i, "张三", "14", true, new Date(), new BigDecimal("111112345.6789")); // 第一个参数指定单元格的列数、第二个参数指定单元格的行数，第三个指定写的字符串内容 // 填充数字， import jxl.write.Number; Number label1 = new Number(0, i, user.getId()); // 填充文本 Label label2 = new Label(1, i, user.getName()); Label label3 = new Label(2, i, user.getAge()); // 填充布尔值， import jxl.write.Boolean; Boolean label4 = new Boolean(3, i, user.getSex()); // 填充日期 SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"); String date = sdf.format(user.getCreateTime()); Label label5 = new Label(4, i, date); // 填充格式化的数字, 保留6位小数，不足六位的时候有几位保留几位。非小数部分用千位符隔开 jxl.write.NumberFormat nf = new jxl.write.NumberFormat("###,###,###.######"); jxl.write.WritableCellFormat wcf = new jxl.write.WritableCellFormat(nf); jxl.write.Number label6 = new jxl.write.Number(5, i, user.getSalary().doubleValue(), wcf); try &#123; sheet.addCell(label1); sheet.addCell(label2); sheet.addCell(label3); sheet.addCell(label4); sheet.addCell(label5); sheet.addCell(label6); &#125; catch (WriteException e) &#123; e.printStackTrace(); &#125; &#125; try &#123; wwb.write(); wwb.close(); is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (WriteException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 根据模板，生成对应的Excel，并填充数据(文本)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import jxl.CellView;import jxl.Workbook;import jxl.WorkbookSettings;import jxl.format.ScriptStyle;import jxl.format.UnderlineStyle;import jxl.read.biff.BiffException;import jxl.write.Boolean;import jxl.write.*;import jxl.write.Number;import jxl.write.biff.RowsExceededException;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.math.BigDecimal;import java.text.SimpleDateFormat;import java.util.Date;public class Test &#123; private static final int MAX_ROWS = 7; public static void main(String[] args) throws IOException, BiffException &#123; // TODO Auto-generated method stub // 表格要导出的目录 String outPath = "C:\\Users\\swust306xu\\Desktop\\sheet.xls"; FileOutputStream is = new FileOutputStream(outPath); // 模板文件路径 String templePath = "C:\\Users\\swust306xu\\Desktop\\业务发展指标.xls"; // 读取模板文件 Workbook wb = Workbook.getWorkbook(new File(templePath)); WorkbookSettings wbSettings = new WorkbookSettings (); wbSettings.setWriteAccess(null); // 根据模板文件创建可写的文件，注意这里是createWorkbook(),创建而不是获取 WritableWorkbook wwb = Workbook.createWorkbook(is, wb , wbSettings); // 注意这里是getSheet(), 通过索引，获取模板文件中的sheet页第一页 WritableSheet sheet = wwb.getSheet(0); WritableFont titleWf = new WritableFont(WritableFont.createFont("宋体"),// 字体 12,//WritableFont.DEFAULT_POINT_SIZE, // 字号 WritableFont.NO_BOLD, // 粗体 false, // 斜体 UnderlineStyle.NO_UNDERLINE, // 下划线 Colour.BLACK, // 字体颜色 ScriptStyle.NORMAL_SCRIPT); WritableCellFormat cFormat = new WritableCellFormat(titleWf); try &#123; cFormat.setBorder(jxl.format.Border.ALL, jxl.format.BorderLineStyle.THIN,jxl.format.Colour.BLACK); &#125; catch (WriteException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; CellView cellView = new CellView(); cellView.setAutosize(true); //设置自动大小 Label lab = null; for(int i=5; i&lt;=MAX_ROWS; i++) &#123; // 从第二行开始插入，第一行表头 for(int j=0;j&lt;22;j++) &#123; sheet.setColumnView(i, cellView);//根据内容自动设置列宽 lab = new Label(j,i,"测试方法",cFormat); //Label(col,row,str); try &#123; sheet.addCell(lab); &#125; catch (RowsExceededException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (WriteException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; try &#123; wwb.write(); wwb.close(); is.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (WriteException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>jxl</category>
      </categories>
      <tags>
        <tag>jxl</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常用命令]]></title>
    <url>%2F2017%2F12%2F11%2Fhexocommon%2F</url>
    <content type="text"><![CDATA[Hexo命令总结常用命令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 复合命令12hexo deploy -g #生成加部署hexo server -g #生成加预览 命令简写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 部署步骤每次部署都可以按照下面的步骤，或者用上面的复合命令123hexo cleanhexo generatehexo deploy 本地测试12hexo g #生成hexo s #启动本地服务，进行文章预览调试 浏览器输入 http://localhost:4000 ，查看搭建效果。此后的每次变更_config.yml 文件或者新建文件都可以先用此命令调试，尤其是当你想调试新添加的主题时。可以用一条简化的命令 1hexo s -g 文章头部格式12345678---title: hexocommondate: 2017-12-11 21:23:17tags: - hexocategories: - hexo--- 基本配置参考文章：http://www.shenzekun.cn/hexo的next主题个性化配置教程.html]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Post和Get的区别]]></title>
    <url>%2F2017%2F12%2F11%2Fpostget%2F</url>
    <content type="text"><![CDATA[什么是 HTTP？ 超文本传输协议（HTTP）的设计目的是保证客户机与服务器之间的通信。 HTTP 的工作方式是客户机与服务器之间的请求-应答协议。 web 浏览器可能是客户端，而计算机上的网络应用程序也可能作为服务器端。 举例：客户端（浏览器）向服务器提交HTTP请求；服务器向客户端返回响应。响应包含关于请求的状态信息以及可能被请求的内容。GET请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：/test/demo_form.asp?name1=value1&amp;name2=value2 GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 POST 请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的： POST /test/demo_form.asp HTTP/1.1 Host: w3schools.com name1=value1&amp;name2=value2 POST 请求不会被缓存 POST 请求不会保留在浏览器历史记录中 POST 不能被收藏为书签 GET POST 请求对数据长度没有要求 … GET POST 后退按钮/刷新 可收藏为书签 不可收藏为书签 书签 能被缓存 不能缓存 编码类型 application/x-www-form-urlencoded application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 历史 参数保留在浏览器历史中 参数不会保存在浏览器历史中 对数据长度的限制 是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。 无限制。 对数据类型的限制 只允许 ASCII 字符。 没有限制。也允许二进制数据。 安全性 与 POST 相比，GET 的安全性较差，因为所发送的数据是URL的一部分。在发送密码或其他敏感信息时绝不要使用 GET POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 可见性 数据在 URL 中对所有人都是可见的。 数据不会显示在 URL 中。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>post</tag>
        <tag>get</tag>
      </tags>
  </entry>
</search>
